\subsection{A Simulator for Digital Circuits}
\label{Section 3.3.4}

Designing complex digital systems, such as computers, is an important engineering activity.
Digital systems are constructed by interconnecting simple elements.
Although the behavior of these individual elements is simple, networks of them can have very complex behavior.
Computer simulation of proposed circuit designs is an important tool used by digital systems engineers.
In this section we design a system for performing digital logic simulations.
This system typifies a kind of program called an \newterm{event-driven simulation}, in which actions (“events”) trigger further events that happen at a later time, which in turn trigger more events, and so on.

Our computational model of a circuit will be composed of objects that correspond to the elementary components from which the circuit is constructed.
There are \newterm{wires}, which carry \newterm{digital signals}.
A digital signal may at any moment have only one of two possible values, \( 0 \) and \( 1 \).
There are also various types of digital \newterm{function boxes}, which connect wires carrying input signals to other output wires.
Such boxes produce output signals computed from their input signals.
The output signal is delayed by a time that depends on the type of the function box.
For example, an \newterm{inverter} is a primitive function box that inverts its input.
If the input signal to an inverter changes to \( 0 \), then one inverter-delay later the inverter will change its output signal to \( 1 \).
If the input signal to an inverter changes to \( 1 \), then one inverter-delay later the inverter will change its output signal to \( 0 \).
We draw an inverter symbolically as in \cref{Figure 3.24}.
An \newterm{and-gate}, also shown in \cref{Figure 3.24}, is a primitive function box with two inputs and one output.
It drives its output signal to a value that is the \newterm{logical and} of the inputs.
That is, if both of its input signals become \( 1 \), then one and-gate-delay time later the and-gate will force its output signal to be \( 1 \);
otherwise the output will be \( 0 \).
An \newterm{or-gate} is a similar two-input primitive function box that drives its output signal to a value that is the \newterm{logical or} of the inputs.
That is, the output will become \( 1 \) if at least one of the input signals is \( 1 \);
otherwise the output will become \( 0 \).

\begin{figure}[tb]
	\centering
	\includesvg[width=74mm]{fig/chap3/Fig3.24b.svg}
	\caption{
		Primitive functions in the digital logic simulator.
	}
	\label{Figure 3.24}
\end{figure}

We can connect primitive functions together to construct more complex functions.
To accomplish this we wire the outputs of some function boxes to the inputs of other function boxes.
For example, the \newterm{half-adder} circuit shown in \cref{Figure 3.25} consists of an or-gate, two and-gates, and an inverter.
It takes two input signals, A and B, and has two output signals, S and C.
S will become 1 whenever precisely one of A and B is 1, and C will become 1 whenever A and B are both 1.
We can see from the figure that, because of the delays involved, the outputs may be generated at different times.
Many of the difficulties in the design of digital circuits arise from this fact.

\begin{figure}[tb]
	\centering
	\includesvg[width=72mm]{fig/chap3/Fig3.25c.svg}
	\caption{
		A half-adder circuit.
	}
	\label{Figure 3.25}
\end{figure}

We will now build a program for modeling the digital logic circuits we wish to study.
The program will construct computational objects modeling the wires, which will “hold” the signals.
Function boxes will be modeled by procedures that enforce the correct relationships among the signals.

One basic element of our simulation will be a procedure \code{make-wire}, which constructs wires.
For example, we can construct six wires as follows:
\begin{scheme}
  (define a (make-wire))
  (define b (make-wire))
  (define c (make-wire))
  (define d (make-wire))
  (define e (make-wire))
  (define s (make-wire))
\end{scheme}

We attach a function box to a set of wires by calling a procedure that constructs that kind of box.
The arguments to the constructor procedure are the wires to be attached to the box.
For example, given that we can construct and-gates, or-gates, and inverters, we can wire together the half-adder shown in \cref{Figure 3.25}:
\begin{scheme}
  (or-gate a b d)
  ~\outprint{ok}~

  (and-gate a b c)
  ~\outprint{ok}~

  (inverter c e)
  ~\outprint{ok}~

  (and-gate d e s)
  ~\outprint{ok}~
\end{scheme}

\begin{figure}[tb]
	\centering
	\includesvg[width=74mm]{fig/chap3/Fig3.26a.svg}
	\caption{
		A full-adder circuit.
	}
	\label{Figure 3.26}
\end{figure}

Better yet, we can explicitly name this operation by defining a procedure \code{half-adder} that constructs this circuit, given the four external wires to be attached to the half-adder:
\begin{scheme}
  (define (half-adder a b s c)
    (let ((d (make-wire)) (e (make-wire)))
      (or-gate a b d)
      (and-gate a b c)
      (inverter c e)
      (and-gate d e s)
      'ok))
\end{scheme}
The advantage of making this definition is that we can use \code{half-adder} itself as a building block in creating more complex circuits.
\cref{Figure 3.26}, for example, shows a \newterm{full-adder} composed of two half-adders and an or-gate.%
\footnote{
	A full-adder is a basic circuit element used in adding two binary numbers.
	Here \( A \) and \( B \) are the bits at corresponding positions in the two numbers to be added, and \( C_{\mathrm{in}} \) is the carry bit from the addition one place to the right.
	The circuit generates SUM, which is the sum bit in the corresponding position, and \( C_{\mathrm{out}} \), which is the carry bit to be propagated to the left.
}
We can construct a full-adder as follows:
\begin{scheme}
  (define (full-adder a b c-in sum c-out)
    (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
      (half-adder b c-in s c1)
      (half-adder a s sum c2)
      (or-gate c1 c2 c-out)
      'ok))
\end{scheme}
Having defined \code{full-adder} as a procedure, we can now use it as a building block for creating still more complex circuits.
(For example, see \cref{Exercise 3.30}.)

In essence, our simulator provides us with the tools to construct a language of circuits.
If we adopt the general perspective on languages with which we approached the study of Lisp in \cref{Section 1.1}, we can say that the primitive function boxes form the primitive elements of the language, that wiring boxes together provides a means of combination, and that specifying wiring patterns as procedures serves as a means of abstraction.



\subsubsection*{Primitive function boxes}

The primitive function boxes implement the “forces” by which a change in the signal on one wire influences the signals on other wires.
To build function boxes, we use the following operations on wires:
\begin{itemize}

\item
	\code{(get-signal ⟨\var{wire}⟩)} \\
	returns the current value of the signal on the wire.

\item
	\code{(set-signal! ⟨\var{wire}⟩ ⟨\var{new value}⟩)} \\
	changes the value of the signal on the wire to the new value.

\item
	\code{(add-action! ⟨\var{wire}⟩ ⟨\var{procedure of no arguments}⟩)} \\
	asserts that the designated procedure should be run whenever the signal on the wire changes value.
	Such procedures are the vehicles by which changes in the signal value on the wire are communicated to other wires.

\end{itemize}
In addition, we will make use of a procedure \code{after-delay} that takes a time delay and a procedure to be run and executes the given procedure after the given delay.

Using these procedures, we can define the primitive digital logic functions.
To connect an input to an output through an inverter, we use \code{add-action!} to associate with the input wire a procedure that will be run whenever the signal on the input wire changes value.
The procedure computes the \code{logical-not} of the input signal, and then, after one \code{inverter-delay}, sets the output signal to be this new value:
\begin{scheme}
  (define (inverter input output)
    (define (invert-input)
      (let ((new-value (logical-not (get-signal input))))
        (after-delay inverter-delay
                     (lambda () (set-signal! output new-value)))))
    (add-action! input invert-input) 'ok)
  (define (logical-not s)
    (cond ((= s 0) 1)
          ((= s 1) 0)
          (else (error "Invalid signal" s))))
\end{scheme}

An and-gate is a little more complex.
The action procedure must be run if either of the inputs to the gate changes.
It computes the \code{logical-and} (using a procedure analogous to \code{logical-not}) of the values of the signals on the input wires and sets up a change to the new value to occur on the output wire after one \code{and-gate-delay}.
\begin{scheme}
  (define (and-gate a1 a2 output)
    (define (and-action-procedure)
      (let ((new-value
             (logical-and (get-signal a1) (get-signal a2))))
        (after-delay
         and-gate-delay
         (lambda () (set-signal! output new-value)))))
    (add-action! a1 and-action-procedure)
    (add-action! a2 and-action-procedure)
    'ok)
\end{scheme}



\begin{exercise}
	\label{Exercise 3.28}
	Define an or-gate as a primitive function box.
	Your \code{or-gate} constructor should be similar to \code{and-gate}.
\end{exercise}



\begin{exercise}
	\label{Exercise 3.29}
	Another way to construct an or-gate is as a compound digital logic device, built from and-gates and inverters.
	Define a procedure \code{or-gate} that accomplishes this.
	What is the delay time of the or-gate in terms of \code{and-gate-delay} and \code{inverter-delay}?
\end{exercise}



\begin{exercise}
	\label{Exercise 3.30}
	\cref{Figure 3.27} shows a \newterm{ripple-carry adder} formed by stringing together \( n \) full-adders.
	This is the simplest form of parallel adder for adding two \( n \)-bit binary numbers.
	The inputs \( A_1, A_2, A_3, \dotsc, A_n \) and \( B_1, B_2, B_3, \dotsc, B_n \) are the two binary numbers to be added (each \( A_k \) and \( B_k \) is a \( 0 \) or a \( 1 \)).
	The circuit generates \( S_1, S_2, S_3, \dotsc, S_n \), the \( n \) bits of the sum, and \( C \), the carry from the addition.
	Write a procedure \code{ripple-carry-adder} that generates this circuit.
	The procedure should take as arguments three lists of \( n \) wires each---the \( A_k \), the \( B_k \), and the \( S_k \)---and also another wire \( C \).
	The major drawback of the ripple-carry adder is the need to wait for the carry signals to propagate.
	What is the delay needed to obtain the complete output from an \( n \)-bit ripple-carry adder, expressed in terms of the delays for and-gates, or-gates, and inverters?
\end{exercise}



\begin{figure}[tb]
	\centering
	\includesvg[width=96mm]{fig/chap3/Fig3.27a.svg}
	\caption{
		A ripple-carry adder for \( n \)-bit numbers.
	}
	\label{Figure 3.27}
\end{figure}



\subsubsection*{Representing wires}

A wire in our simulation will be a computational object with two local state variables:
a \code{signal-value} (initially taken to be 0) and a collection of \code{action-procedures} to be run when the signal changes value.
We implement the wire, using message-passing style, as a collection of local procedures together with a \code{dispatch} procedure that selects the appropriate local operation, just as we did with the simple bank-account object in \cref{Section 3.1.1}:
\begin{scheme}
  (define (make-wire)
    (let ((signal-value 0) (action-procedures '()))
      (define (set-my-signal! new-value)
        (if (not (= signal-value new-value))
            (begin (set! signal-value new-value)
                   (call-each action-procedures))
            'done))
      (define (accept-action-procedure! proc)
        (set! action-procedures
              (cons proc action-procedures))
        (proc))
      (define (dispatch m)
        (cond ((eq? m 'get-signal) signal-value)
              ((eq? m 'set-signal!) set-my-signal!)
              ((eq? m 'add-action!) accept-action-procedure!)
              (else (error "Unknown operation: WIRE" m))))
      dispatch))
\end{scheme}
The local procedure \code{set-my-signal!} tests whether the new signal value changes the signal on the wire.
If so, it runs each of the action procedures, using the following procedure \code{call-each}, which calls each of the items in a list of no-argument procedures:
\begin{scheme}
  (define (call-each procedures)
    (if (null? procedures)
        'done
        (begin ((car procedures))
               (call-each (cdr procedures)))))
\end{scheme}
The local procedure \code{accept-action-procedure!} adds the given procedure to the list of procedures to be run, and then runs the new procedure once.
(See \cref{Exercise 3.31}.)

With the local \code{dispatch} procedure set up as specified, we can provide the following procedures to access the local operations on wires:%
\footnote{
	\label{Footnote 27} These procedures are simply syntactic sugar that allow us to use ordinary procedural syntax to access the local procedures of objects.
	It is striking that we can interchange the role of “procedures”  and  “data” in such a simple way.
	For example, if we write \code{(wire 'get-signal)} we think of \code{wire} as a procedure that is called with the message \code{get-signal} as input.
	Alternatively, writing \code{(get-signal wire)} encourages us to think of \code{wire} as a data object that is the input to a procedure \code{get-signal}.
	The truth of the matter is that, in a language in which we can deal with procedures as objects, there is no fundamental difference between “procedures”  and  “data,” and we can choose our syntactic sugar to allow us to program in whatever style we choose.
}
\begin{scheme}
  (define (get-signal wire) (wire 'get-signal))

  (define (set-signal! wire new-value)
    ((wire 'set-signal!) new-value))

  (define (add-action! wire action-procedure)
    ((wire 'add-action!) action-procedure))
\end{scheme}

Wires, which have time-varying signals and may be incrementally attached to devices, are typical of mutable objects.
We have modeled them as procedures with local state variables that are modified by assignment.
When a new wire is created, a new set of state variables is allocated (by the \code{let} expression in \code{make-wire}) and a new \code{dispatch} procedure is constructed and returned, capturing the environment with the new state variables.

The wires are shared among the various devices that have been connected to them.
Thus, a change made by an interaction with one device will affect all the other devices attached to the wire.
The wire communicates the change to its neighbors by calling the action procedures provided to it when the connections were established.



\subsubsection*{The agenda}

The only thing needed to complete the simulator is \code{after-delay}.
The idea here is that we maintain a data structure, called an \newterm{agenda}, that contains a schedule of things to do.
The following operations are defined for agendas:
\begin{itemize}

	\item
		\code{(make-agenda)} \\
		returns a new empty agenda.

	\item
		\code{(empty-agenda? ⟨\var{agenda}⟩)} \\
		is true if the specified agenda is empty.

	\item
		\code{(first-agenda-item ⟨agenda⟩)} \\
		returns the first item on the agenda.

	\item
		\code{(remove-first-agenda-item! ⟨\var{agenda}⟩)} \\
		modifies the agenda by removing the first item.

	\item
		\code{(add-to-agenda! ⟨\var{time}⟩ ⟨\var{action}⟩ ⟨\var{agenda}⟩)} \\
	modifies the agenda by adding the given action procedure to be run at the specified time.

	\item
		\code{(current-time ⟨agenda⟩)} \\
		returns the current simulation time.

\end{itemize}
The particular agenda that we use is denoted by \code{the-agenda}.
The procedure \code{after-delay} adds new elements to \code{the-agenda}:
\begin{scheme}
  (define (after-delay delay action)
    (add-to-agenda! (+ delay (current-time the-agenda))
                    action
                    the-agenda))
\end{scheme}

The simulation is driven by the procedure \code{propagate}, which operates on \code{the-agenda}, executing each procedure on the agenda in sequence.
In general, as the simulation runs, new items will be added to the agenda, and \code{propagate} will continue the simulation as long as there are items on the agenda:
\begin{scheme}
  (define (propagate)
    (if (empty-agenda? the-agenda)
        'done
        (let ((first-item (first-agenda-item the-agenda)))
          (first-item)
          (remove-first-agenda-item! the-agenda)
          (propagate))))
\end{scheme}



\subsubsection*{A sample simulation}

The following procedure, which places a “probe” on a wire, shows the simulator in action.
The probe tells the wire that, whenever its signal changes value, it should print the new signal value, together with the current time and a name that identifies the wire:
\begin{scheme}
  (define (probe name wire)
    (add-action! wire
                 (lambda ()
                   (newline)
                   (display name) (display " ")
                   (display (current-time the-agenda))
                   (display "  New-value = ")
                   (display (get-signal wire)))))
\end{scheme}

We begin by initializing the agenda and specifying delays for the primitive
function boxes:
\begin{scheme}
  (define the-agenda (make-agenda))
  (define inverter-delay 2)
  (define and-gate-delay 3)
  (define or-gate-delay 5)
\end{scheme}
Now we define four wires, placing probes on two of them:
\begin{scheme}
  (define input-1 (make-wire))
  (define input-2 (make-wire))
  (define sum (make-wire))
  (define carry (make-wire))

  (probe 'sum sum)
  ~\outprint{sum 0  New-value = 0}~

  (probe 'carry carry)
  ~\outprint{carry 0  New-value = 0}~
\end{scheme}
Next we connect the wires in a half-adder circuit (as in \cref{Figure 3.25}), set the signal on \code{input-1} to \( 1 \), and run the simulation:
\begin{scheme}
  (half-adder input-1 input-2 sum carry)
  ~\outprint{ok}~

  (set-signal! input-1 1)
  ~\outprint{done}~

  (propagate)
  ~\outprint{sum 8  New-value = 1}~
  ~\outprint{done}~
\end{scheme}
The \code{sum} signal changes to \( 1 \) at time \( 8 \).
We are now eight time units from the beginning of the simulation.
At this point, we can set the signal on \code{input-2} to \( 1 \) and allow the values to propagate:
\begin{scheme}
  (set-signal! input-2 1)
  ~\outprint{done}~

  (propagate)
  ~\outprint{carry 11  New-value = 1}~
  ~\outprint{sum 16  New-value = 0}~
  ~\outprint{done}~
\end{scheme}
The \code{carry} changes to 1 at time 11 and the \code{sum} changes to 0 at
time 16.



\begin{exercise}
	\label{Exercise 3.31}
	The internal procedure \code{accept-action-procedure!} defined in \code{make-wire} specifies that when a new action procedure is added to a wire, the procedure is immediately run.
	Explain why this initialization is necessary.
	In particular, trace through the half-adder example in the paragraphs above and say how the system’s response would differ if we had defined \code{accept-action-procedure!} as
	\begin{scheme}
	  (define (accept-action-procedure! proc)
	    (set! action-procedures
	          (cons proc action-procedures)))
	\end{scheme}
\end{exercise}



\subsubsection*{Implementing the agenda}

Finally, we give details of the agenda data structure, which holds the procedures that are scheduled for future execution.

The agenda is made up of \newterm{time segments}.
Each time segment is a pair consisting of a number (the time) and a queue (see \cref{Exercise 3.32}) that holds the procedures that are scheduled to be run during that time segment.
\begin{scheme}
  (define (make-time-segment time queue)
    (cons time queue))

  (define (segment-time s) (car s))

  (define (segment-queue s) (cdr s))
\end{scheme}
We will operate on the time-segment queues using the queue operations described in \cref{Section 3.3.2}.

The agenda itself is a one-dimensional table of time segments.
It differs from the tables described in \cref{Section 3.3.3} in that the segments will be sorted in order of increasing time.
In addition, we store the \newterm{current time} (i.e., the time of the last action that was processed) at the head of the agenda.
A newly constructed agenda has no time segments and has a current time of \( 0 \):%
\footnote{
	The agenda is a headed list, like the tables in \cref{Section 3.3.3}, but since the list is headed by the time, we do not need an additional dummy header (such as the \code{*table*} symbol used with tables).
}
\begin{scheme}
  (define (make-agenda) (list 0))

  (define (current-time agenda) (car agenda))

  (define (set-current-time! agenda time)
    (set-car! agenda time))

  (define (segments agenda) (cdr agenda))

  (define (set-segments! agenda segments)
    (set-cdr! agenda segments))

  (define (first-segment agenda) (car (segments agenda)))

  (define (rest-segments agenda) (cdr (segments agenda)))
\end{scheme}

An agenda is empty if it has no time segments:
\begin{scheme}
  (define (empty-agenda? agenda)
    (null? (segments agenda)))
\end{scheme}

To add an action to an agenda, we first check if the agenda is empty.
If so, we create a time segment for the action and install this in the agenda.
Otherwise, we scan the agenda, examining the time of each segment.
If we find a segment for our appointed time, we add the action to the associated queue.
If we reach a time later than the one to which we are appointed, we insert a new time segment into the agenda just before it.
If we reach the end of the agenda, we must create a new time segment at the end.
\begin{scheme}
  (define (add-to-agenda! time action agenda)
    (define (belongs-before? segments)
      (or (null? segments)
          (< time (segment-time (car segments)))))
    (define (make-new-time-segment time action)
      (let ((q (make-queue)))
        (insert-queue! q action)
        (make-time-segment time q)))
    (define (add-to-segments! segments)
      (if (= (segment-time (car segments)) time)
          (insert-queue! (segment-queue (car segments))
                         action)
          (let ((rest (cdr segments)))
            (if (belongs-before? rest)
                (set-cdr!
                 segments
                 (cons (make-new-time-segment time action)
                       (cdr segments)))
                (add-to-segments! rest)))))
    (let ((segments (segments agenda)))
      (if (belongs-before? segments)
          (set-segments!
           agenda
           (cons (make-new-time-segment time action)
                 segments))
          (add-to-segments! segments))))
\end{scheme}

The procedure that removes the first item from the agenda deletes the item at the front of the queue in the first time segment.
If this deletion makes the time segment empty, we remove it from the list of segments:%
\footnote{
	Observe that the \code{if} expression in this procedure has no \code{⟨\var{alternative}⟩} expression.
	Such a “one-armed \code{if} statement” is used to decide whether to do something, rather than to select between two expressions.
	An \code{if} expression returns an unspecified value if the predicate is false and there is no \code{⟨\var{alternative}⟩}.
}
\begin{scheme}
  (define (remove-first-agenda-item! agenda)
    (let ((q (segment-queue (first-segment agenda))))
      (delete-queue! q)
      (if (empty-queue? q)
          (set-segments! agenda (rest-segments agenda)))))
\end{scheme}

The first agenda item is found at the head of the queue in the first time segment.
Whenever we extract an item, we also update the current time:%
\footnote{
	In this way, the current time will always be the time of the action most recently processed.
	Storing this time at the head of the agenda ensures that it will still be available even if the associated time segment has been deleted.
}
\begin{scheme}
  (define (first-agenda-item agenda)
    (if (empty-agenda? agenda)
        (error "Agenda is empty: FIRST-AGENDA-ITEM")
        (let ((first-seg (first-segment agenda)))
          (set-current-time! agenda
                             (segment-time first-seg))
          (front-queue (segment-queue first-seg)))))
\end{scheme}



\begin{exercise}
	\label{Exercise 3.32}
	The procedures to be run during each time segment of the agenda are kept in a queue.
	Thus, the procedures for each segment are called in the order in which they were added to the agenda (first in, first out).
	Explain why this order must be used.
	In particular, trace the behavior of an and-gate whose inputs change from \( 0 \), \( 1 \) to \( 1 \), \( 0 \) in the same segment and say how the behavior would differ if we stored a segment’s procedures in an ordinary list, adding and removing procedures only at the front (last in, first out).
\end{exercise}
