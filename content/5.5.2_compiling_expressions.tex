\subsection{Compiling Expressions}
\label{Section 5.5.2}

In this section and the next we implement the code generators to which the \code{compile} procedure dispatches.



\subsubsection*{Compiling linkage code}

In general, the output of each code generator will end with instructions---generated by the procedure \code{compile-linkage}---that implement the required linkage.
If the linkage is \code{return} then we must generate the instruction \code{(goto (reg continue))}.
This needs the \code{continue} register and does not modify any registers.
If the linkage is \code{next}, then we needn’t include any additional instructions.
Otherwise, the linkage is a label, and we generate a \code{goto} to that label, an instruction that does not need or modify any registers.%
\footnote{
	This procedure uses a feature of Lisp called \newterm{backquote} (or \newterm{quasiquote}) that is handy for constructing lists.
	Preceding a list with a backquote symbol is much like quoting it, except that anything in the list that is flagged with a comma is evaluated.

	For example, if the value of \code{linkage} is the symbol \code{branch25}, then the expression \code{`((goto (label ,linkage)))} evaluates to the list \code{((goto (label branch25)))}.
	Similarly, if the value of \code{x} is the list \code{(a b c)}, then \code{`(1 2 ,(car x))} evaluates to the list \code{(1 2 a)}.
}

\begin{scheme}
  (define (compile-linkage linkage)
    (cond ((eq? linkage 'return)
           (make-instruction-sequence '(continue) '()
            '((goto (reg continue)))))
          ((eq? linkage 'next)
           (empty-instruction-sequence))
          (else
           (make-instruction-sequence '() '()
            `((goto (label ,linkage)))))))
\end{scheme}
The linkage code is appended to an instruction sequence by \code{preserving} the \code{continue} register, since a \code{return} linkage will require the \code{continue} register:
If the given instruction sequence modifies \code{continue} and the linkage code needs it, \code{continue} will be saved and restored.
\begin{scheme}
  (define (end-with-linkage linkage instruction-sequence)
    (preserving '(continue)
     instruction-sequence
     (compile-linkage linkage)))
\end{scheme}



\subsubsection*{Compiling simple expressions}

The code generators for self-evaluating expressions, quotations, and variables construct instruction sequences that assign the required value to the target register and then proceed as specified by the linkage descriptor.
\begin{scheme}
  (define (compile-self-evaluating exp target linkage)
    (end-with-linkage linkage
     (make-instruction-sequence '() (list target)
      `((assign ,target (const ,exp))))))

  (define (compile-quoted exp target linkage)
    (end-with-linkage linkage
     (make-instruction-sequence '() (list target)
      `((assign ,target (const ,(text-of-quotation exp)))))))

  (define (compile-variable exp target linkage)
    (end-with-linkage linkage
     (make-instruction-sequence '(env) (list target)
      `((assign ,target
                (op lookup-variable-value)
                (const ,exp)
                (reg env))))))
\end{scheme}
All these assignment instructions modify the target register, and the one that looks up a variable needs the \code{env} register.

Assignments and definitions are handled much as they are in the interpreter.
We recursively generate code that computes the value to be assigned to the variable, and append to it a two-instruction sequence that actually sets or defines the variable and assigns the value of the whole expression (the symbol \code{ok}) to the target register.
The recursive compilation has target \code{val} and linkage \code{next} so that the code will put its result into \code{val} and continue with the code that is appended after it.
The appending is done preserving \code{env}, since the environment is needed for setting or defining the variable and the code for the variable value could be the compilation of a complex expression that might modify the registers in arbitrary ways.

\begin{scheme}
  (define (compile-assignment exp target linkage)
    (let ((var (assignment-variable exp))
          (get-value-code
           (compile (assignment-value exp) 'val 'next)))
      (end-with-linkage linkage
       (preserving '(env)
        get-value-code
        (make-instruction-sequence '(env val) (list target)
         `((perform (op set-variable-value!)
                    (const ,var)
                    (reg val)
                    (reg env))
           (assign ,target (const ok))))))))

  (define (compile-definition exp target linkage)
    (let ((var (definition-variable exp))
          (get-value-code
           (compile (definition-value exp) 'val 'next)))
      (end-with-linkage linkage
       (preserving '(env)
        get-value-code
        (make-instruction-sequence '(env val) (list target)
         `((perform (op define-variable!)
                    (const ,var)
                    (reg val)
                    (reg env))
           (assign ,target (const ok))))))))
\end{scheme}
The appended two-instruction sequence requires \code{env} and \code{val} and modifies the target.
Note that although we preserve \code{env} for this sequence, we do not preserve \code{val}, because the \code{get-value-code} is designed to explicitly place its result in \code{val} for use by this sequence.
(In fact, if we did preserve \code{val}, we would have a bug, because this would cause the previous contents of \code{val} to be restored right after the \code{get-value-code} is run.)



\subsubsection*{Compiling conditional expressions}

The code for an \code{if} expression compiled with a given target and linkage has the form
\begin{scheme}
   ⟨~\emph{compilation of predicate, target \code{val}, linkage \code{next}}~⟩
   (test (op false?) (reg val))
   (branch (label false-branch))
  true-branch
   ⟨~\emph{compilation of consequent with given target and given linkage or \code{after-if}}~⟩
  false-branch
   ⟨~\emph{compilation of alternative with given target and linkage}~⟩
  after-if
\end{scheme}

To generate this code, we compile the predicate, consequent, and alternative, and combine the resulting code with instructions to test the predicate result and with newly generated labels to mark the true and false branches and the end of the conditional.%
\footnote{
	We can’t just use the labels \code{true-branch}, \code{false-branch}, and \code{after-if} as shown above, because there might be more than one \code{if} in the program.
	The compiler uses the procedure \code{make-label} to generate labels.
	\code{make-label} takes a symbol as argument and returns a new symbol that begins with the given symbol.
	For example, successive calls to \code{(make-label 'a)} would return \code{a1}, \code{a2}, and so on.
	\code{make-label} can be implemented similarly to the generation of unique variable names in the query language, as follows:
	\begin{smallscheme}
	  (define label-counter 0)

	  (define (new-label-number)
	    (set! label-counter (+ 1 label-counter))
	    label-counter)

	  (define (make-label name)
	    (string->symbol
	      (string-append (symbol->string name)
	                     (number->string (new-label-number)))))
	\end{smallscheme}
}
In this arrangement of code, we must branch around the true branch if the test is false.
The only slight complication is in how the linkage for the true branch should be handled.
If the linkage for the conditional is \code{return} or a label, then the true and false branches will both use this same linkage.
If the linkage is \code{next}, the true branch ends with a jump around the code for the false branch to the label at the end of the conditional.
\begin{scheme}
  (define (compile-if exp target linkage)
    (let ((t-branch (make-label 'true-branch))
          (f-branch (make-label 'false-branch))
          (after-if (make-label 'after-if)))
      (let ((consequent-linkage
             (if (eq? linkage 'next) after-if linkage)))
        (let ((p-code (compile (if-predicate exp) 'val 'next))
              (c-code
               (compile
                (if-consequent exp) target
                                    consequent-linkage))
              (a-code
               (compile (if-alternative exp) target linkage)))
          (preserving '(env continue)
           p-code
           (append-instruction-sequences
            (make-instruction-sequence '(val) '()
             `((test (op false?) (reg val))
               (branch (label ,f-branch))))
            (parallel-instruction-sequences
             (append-instruction-sequences t-branch c-code)
             (append-instruction-sequences f-branch a-code))
            after-if))))))
\end{scheme}
\code{env} is preserved around the predicate code because it could be needed by the true and false branches, and \code{continue} is preserved because it could be needed by the linkage code in those branches.
The code for the true and false branches (which are not executed sequentially) is appended using a special combiner \code{parallel-instruction-sequences} described in \link{Section 5.5.4}.

Note that \code{cond} is a derived expression, so all that the compiler needs to do handle it is to apply the \code{cond->if} transformer (from \link{Section 4.1.2}) and compile the resulting \code{if} expression.



\subsubsection*{Compiling sequences}

The compilation of sequences (from procedure bodies or explicit \code{begin} expressions) parallels their evaluation.
Each expression of the sequence is compiled---the last expression with the linkage specified for the sequence, and the other expressions with linkage \code{next} (to execute the rest of the sequence).
The instruction sequences for the individual expressions are appended to form a single instruction sequence, such that \code{env} (needed for the rest of the sequence) and \code{continue} (possibly needed for the linkage at the end of the sequence) are preserved.

\begin{scheme}
  (define (compile-sequence seq target linkage)
    (if (last-exp? seq)
        (compile (first-exp seq) target linkage)
        (preserving
         '(env continue)
         (compile (first-exp seq) target 'next)
         (compile-sequence (rest-exps seq) target linkage))))
\end{scheme}



\subsubsection*{Compiling \code{lambda} expressions}

\code{lambda} expressions construct procedures.
The object code for a \code{lambda} expression must have the form
\begin{scheme}
  ⟨~\emph{construct procedure object and assign it to target register}~⟩
  ⟨~\var{linkage}~⟩
\end{scheme}
When we compile the \code{lambda} expression, we also generate the code for the procedure body.
Although the body won’t be executed at the time of procedure construction, it is convenient to insert it into the object code right after the code for the \code{lambda}.
If the linkage for the \code{lambda} expression is a label or \code{return}, this is fine.
But if the linkage is \code{next}, we will need to skip around the code for the procedure body by using a linkage that jumps to a label that is inserted after the body.
The object code thus has the form
\begin{scheme}
   ⟨~\emph{construct procedure object and assign it to target register}~⟩
   ⟨~\emph{code for given linkage}~⟩ ~\emph{or}~ (goto (label after-lambda))
   ⟨~\emph{compilation of procedure body}~⟩
  after-lambda
\end{scheme}

\code{compile-lambda} generates the code for constructing the procedure object followed by the code for the procedure body.
The procedure object will be constructed at run time by combining the current environment (the environment at the point of definition) with the entry point to the compiled procedure body (a newly generated label).%
\footnote{
	\label{Footnote 38}
	We need machine operations to implement a data structure for representing compiled procedures, analogous to the structure for compound procedures described in \link{Section 4.1.3}:

	\begin{smallscheme}
	  (define (make-compiled-procedure entry env)
	    (list 'compiled-procedure entry env))

	  (define (compiled-procedure? proc)
	    (tagged-list? proc 'compiled-procedure))

	  (define (compiled-procedure-entry c-proc) (cadr c-proc))

	  (define (compiled-procedure-env c-proc) (caddr c-proc))
	\end{smallscheme}
}
\begin{scheme}
  (define (compile-lambda exp target linkage)
    (let ((proc-entry (make-label 'entry))
          (after-lambda (make-label 'after-lambda)))
      (let ((lambda-linkage
             (if (eq? linkage 'next) after-lambda linkage)))
        (append-instruction-sequences
         (tack-on-instruction-sequence
          (end-with-linkage lambda-linkage
           (make-instruction-sequence '(env) (list target)
            `((assign ,target
                      (op make-compiled-procedure)
                      (label ,proc-entry)
                      (reg env)))))
          (compile-lambda-body exp proc-entry))
         after-lambda))))
\end{scheme}
\code{compile-lambda} uses the special combiner \code{tack-on-instruction-sequence} rather than \code{append-instruction-sequences} (\link{Section 5.5.4}) to append the procedure body to the \code{lambda} expression code, because the body is not part of the sequence of instructions that will be executed when the combined sequence is entered;
rather, it is in the sequence only because that was a convenient place to put it.

\code{compile-lambda-body} constructs the code for the body of the procedure.
This code begins with a label for the entry point.
Next come instructions that will cause the run-time evaluation environment to switch to the correct environment for evaluating the procedure body---namely, the definition environment of the procedure, extended to include the bindings of the formal parameters to the arguments with which the procedure is called.
After this comes the code for the sequence of expressions that makes up the procedure body.
The sequence is compiled with linkage \code{return} and target \code{val} so that it will end by returning from the procedure with the procedure result in \code{val}.

\begin{scheme}
  (define (compile-lambda-body exp proc-entry)
    (let ((formals (lambda-parameters exp)))
      (append-instruction-sequences
       (make-instruction-sequence '(env proc argl) '(env)
        `(,proc-entry
          (assign env
                  (op compiled-procedure-env)
                  (reg proc))
          (assign env
                  (op extend-environment)
                  (const ,formals)
                  (reg argl)
                  (reg env))))
       (compile-sequence (lambda-body exp) 'val 'return))))
\end{scheme}
