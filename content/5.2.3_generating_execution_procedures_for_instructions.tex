\subsection{Generating Execution Procedures for Instructions}
\label{Section 5.2.3}

The assembler calls \code{make-execution-procedure} to generate the execution procedure for an instruction.
Like the \code{analyze} procedure in the evaluator of \cref{Section 4.1.7}, this dispatches on the type of instruction to generate the appropriate execution procedure.

\begin{scheme}
  (define (make-execution-procedure
           inst labels machine pc flag stack ops)
    (cond ((eq? (car inst) 'assign)
           (make-assign inst machine labels ops pc))
          ((eq? (car inst) 'test)
           (make-test inst machine labels ops flag pc))
          ((eq? (car inst) 'branch)
           (make-branch inst machine labels flag pc))
          ((eq? (car inst) 'goto)
           (make-goto inst machine labels pc))
          ((eq? (car inst) 'save)
           (make-save inst machine stack pc))
          ((eq? (car inst) 'restore)
           (make-restore inst machine stack pc))
          ((eq? (car inst) 'perform)
           (make-perform inst machine labels ops pc))
          (else
           (error "Unknown instruction type: ASSEMBLE"
                  inst))))
\end{scheme}

For each type of instruction in the register-machine language, there is a generator that builds an appropriate execution procedure.
The details of these procedures determine both the syntax and meaning of the individual instructions in the register-machine language.
We use data abstraction to isolate the detailed syntax of register-machine expressions from the general execution mechanism, as we did for evaluators in \cref{Section 4.1.2}, by using syntax procedures to extract and classify the parts of an instruction.



\subsubsection*{\code{assign} instructions}

The \code{make-assign} procedure handles \code{assign} instructions:
\begin{scheme}
  (define (make-assign inst machine labels operations pc)
    (let ((target
           (get-register machine (assign-reg-name inst)))
          (value-exp (assign-value-exp inst)))
      (let ((value-proc
             (if (operation-exp? value-exp)
                 (make-operation-exp
                  value-exp machine labels operations)
                 (make-primitive-exp
                  (car value-exp) machine labels))))
        (lambda ()   ~\textrm{; execution procedure for \code{assign}}~
          (set-contents! target (value-proc))
          (advance-pc pc)))))
\end{scheme}
\code{make-assign} extracts the target register name (the second element of the instruction) and the value expression (the rest of the list that forms the instruction) from the \code{assign} instruction using the selectors
\begin{scheme}
  (define (assign-reg-name assign-instruction)
    (cadr assign-instruction))

  (define (assign-value-exp assign-instruction)
    (cddr assign-instruction))
\end{scheme}
The register name is looked up with \code{get-register} to produce the target register object.
The value expression is passed to \code{make-operation-exp} if the value is the result of an operation, and to \code{make-primitive-exp} otherwise.
These procedures (shown below) parse the value expression and produce an execution procedure for the value.
This is a procedure of no arguments, called \code{value-proc}, which will be evaluated during the simulation to produce the actual value to be assigned to the register.
Notice that the work of looking up the register name and parsing the value expression is performed just once, at assembly time, not every time the instruction is simulated.
This saving of work is the reason we use execution procedures, and corresponds directly to the saving in work we obtained by separating program analysis from execution in the evaluator of \cref{Section 4.1.7}.

The result returned by \code{make-assign} is the execution procedure for the \code{assign} instruction.
When this procedure is called (by the machine model’s \code{execute} procedure), it sets the contents of the target register to the result obtained by executing \code{value-proc}.
Then it advances the \code{pc} to the next instruction by running the procedure
\begin{scheme}
  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))
\end{scheme}
\code{advance-pc} is the normal termination for all instructions except \code{branch} and \code{goto}.



\subsubsection*{\code{test}, \code{branch}, and \code{goto} instructions}

\code{make-test} handles \code{test} instructions in a similar way.
It extracts the expression that specifies the condition to be tested and generates an execution procedure for it.
At simulation time, the procedure for the condition is called, the result is assigned to the \code{flag} register, and the \code{pc} is advanced:
\begin{scheme}
  (define (make-test inst machine labels operations flag pc)
    (let ((condition (test-condition inst)))
      (if (operation-exp? condition)
          (let ((condition-proc
                 (make-operation-exp
                  condition machine labels operations)))
            (lambda ()
              (set-contents! flag (condition-proc))
              (advance-pc pc)))
          (error "Bad TEST instruction: ASSEMBLE" inst))))

  (define (test-condition test-instruction)
    (cdr test-instruction))
\end{scheme}

The execution procedure for a \code{branch} instruction checks the contents of the \code{flag} register and either sets the contents of the \code{pc} to the branch destination (if the branch is taken) or else just advances the \code{pc} (if the branch is not taken).
Notice that the indicated destination in a \code{branch} instruction must be a label, and the \code{make-branch} procedure enforces this.
Notice also that the label is looked up at assembly time, not each time the \code{branch} instruction is simulated.
\begin{scheme}
  (define (make-branch inst machine labels flag pc)
    (let ((dest (branch-dest inst)))
      (if (label-exp? dest)
          (let ((insts
                 (lookup-label
                  labels
                  (label-exp-label dest))))
            (lambda ()
              (if (get-contents flag)
                  (set-contents! pc insts)
                  (advance-pc pc))))
          (error "Bad BRANCH instruction: ASSEMBLE" inst))))

  (define (branch-dest branch-instruction)
    (cadr branch-instruction))
\end{scheme}

A \code{goto} instruction is similar to a branch, except that the destination may be specified either as a label or as a register, and there is no condition to check---the \code{pc} is always set to the new destination.
\begin{scheme}
  (define (make-goto inst machine labels pc)
    (let ((dest (goto-dest inst)))
      (cond ((label-exp? dest)
             (let ((insts (lookup-label
                           labels
                           (label-exp-label dest))))
               (lambda () (set-contents! pc insts))))
            ((register-exp? dest)
             (let ((reg (get-register
                         machine
                         (register-exp-reg dest))))
               (lambda ()
                 (set-contents! pc (get-contents reg)))))
            (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))

  (define (goto-dest goto-instruction)
    (cadr goto-instruction))
\end{scheme}



\subsubsection*{Other instructions}

The stack instructions \code{save} and \code{restore} simply use the stack with the designated register and advance the \code{pc}:
\begin{scheme}
  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (push stack (get-contents reg))
        (advance-pc pc))))

  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (set-contents! reg (pop stack))
        (advance-pc pc))))

  (define (stack-inst-reg-name stack-instruction)
    (cadr stack-instruction))
\end{scheme}

The final instruction type, handled by \code{make-perform}, generates an execution procedure for the action to be performed.
At simulation time, the action procedure is executed and the \code{pc} advanced.

\begin{scheme}
  (define (make-perform inst machine labels operations pc)
    (let ((action (perform-action inst)))
      (if (operation-exp? action)
          (let ((action-proc
                 (make-operation-exp
                  action machine labels operations)))
            (lambda () (action-proc) (advance-pc pc)))
          (error "Bad PERFORM instruction: ASSEMBLE" inst))))
  (define (perform-action inst) (cdr inst))
\end{scheme}



\subsubsection*{Execution procedures for subexpressions}

The value of a \code{reg}, \code{label}, or \code{const} expression may be needed for assignment to a register (\code{make-assign}) or for input to an operation (\code{make-operation-exp}, below).
The following procedure generates execution procedures to produce values for these expressions during the simulation:
\begin{scheme}
  (define (make-primitive-exp exp machine labels)
    (cond ((constant-exp? exp)
           (let ((c (constant-exp-value exp)))
             (lambda () c)))
          ((label-exp? exp)
           (let ((insts (lookup-label
                         labels
                         (label-exp-label exp))))
             (lambda () insts)))
          ((register-exp? exp)
           (let ((r (get-register machine (register-exp-reg exp))))
             (lambda () (get-contents r))))
          (else (error "Unknown expression type: ASSEMBLE" exp))))
\end{scheme}
The syntax of \code{reg}, \code{label}, and \code{const} expressions is determined by
\begin{scheme}
  (define (register-exp? exp) (tagged-list? exp 'reg))

  (define (register-exp-reg exp) (cadr exp))

  (define (constant-exp? exp) (tagged-list? exp 'const))

  (define (constant-exp-value exp) (cadr exp))

  (define (label-exp? exp) (tagged-list? exp 'label))

  (define (label-exp-label exp) (cadr exp))
\end{scheme}

\code{assign}, \code{perform}, and \code{test} instructions may include the application of a machine operation (specified by an \code{op} expression) to some operands (specified by \code{reg} and \code{const} expressions).
The following procedure produces an execution procedure for an “operation expression”---a list containing the operation and operand expressions from the instruction:
\begin{scheme}
  (define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp)
                           operations))
          (aprocs
           (map (lambda (e)
                  (make-primitive-exp e machine labels))
                (operation-exp-operands exp))))
      (lambda ()
        (apply op (map (lambda (p) (p)) aprocs)))))
\end{scheme}
The syntax of operation expressions is determined by
\begin{scheme}
  (define (operation-exp? exp)
    (and (pair? exp) (tagged-list? (car exp) 'op)))

  (define (operation-exp-op operation-exp)
    (cadr (car operation-exp)))

  (define (operation-exp-operands operation-exp)
    (cdr operation-exp))
\end{scheme}

Observe that the treatment of operation expressions is very much like the treatment of procedure applications by the \code{analyze-application} procedure in the evaluator of \cref{Section 4.1.7} in that we generate an execution procedure for each operand.
At simulation time, we call the operand procedures and apply the Scheme procedure that simulates the operation to the resulting values.
The simulation procedure is found by looking up the operation name in the operation table for the machine:
\begin{scheme}
  (define (lookup-prim symbol operations)
    (let ((val (assoc symbol operations)))
      (if val
          (cadr val)
          (error "Unknown operation: ASSEMBLE"
                 symbol))))
\end{scheme}



\begin{exercise}
	\label{Exercise 5.9}
	The treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers.
	Modify the expression-processing procedures to enforce the condition that operations can be used only with registers and constants.
\end{exercise}



\begin{exercise}
	\label{Exercise 5.10}
	Design a new syntax for register-machine instructions and modify the simulator to use your new syntax.
	Can you implement your new syntax without changing any part of the simulator except the syntax procedures in this section?
\end{exercise}



\begin{exercise}
	\label{Exercise 5.11}
	When we introduced \code{save} and \code{restore} in \cref{Section 5.1.4}, we didn’t specify what would happen if you tried to restore a register that was not the last one saved, as in the sequence
	\begin{scheme}
	  (save y)  (save x)  (restore y)
	\end{scheme}
	There are several reasonable possibilities for the meaning of \code{restore}:
	\begin{enumerate}[label = \alph*., leftmargin = *]

		\item
			\code{(restore y)} puts into \code{y} the last value saved on the stack, regardless of what register that value came from.
			This is the way our simulator behaves.
			Show how to take advantage of this behavior to eliminate one instruction from the Fibonacci machine of \cref{Section 5.1.4} (\cref{Figure 5.12}).

		\item
			\code{(restore y)} puts into \code{y} the last value saved on the stack, but only if that value was saved from \code{y};
			otherwise, it signals an error.
			Modify the simulator to behave this way.
			You will have to change \code{save} to put the register name on the stack along with the value.

		\item
			\code{(restore y)} puts into \code{y} the last value saved from \code{y} regardless of what other registers were saved after \code{y} and not restored.
			Modify the simulator to behave this way.
			You will have to associate a separate stack with each register.
			You should make the \code{initialize-stack} operation initialize all the register stacks.

	\end{enumerate}
\end{exercise}



\begin{exercise}
	\label{Exercise 5.12}
	The simulator can be used to help determine the data paths required for implementing a machine with a given controller.
	Extend the assembler to store the following information in the machine model:
	\begin{itemize}

		\item
			a list of all instructions, with duplicates removed, sorted by instruction type (\code{assign}, \code{goto}, and so on);

		\item
			a list (without duplicates) of the registers used to hold entry points (these are the registers referenced by \code{goto} instructions);

		\item
			a list (without duplicates) of the registers that are \code{save}d or \code{restore}d;

		\item
			for each register, a list (without duplicates) of the sources from which it is assigned (for example, the sources for register \code{val} in the factorial machine of \cref{Figure 5.11} are \code{(const 1)} and \code{((op *) (reg n) (reg val))}).

	\end{itemize}
	Extend the message-passing interface to the machine to provide access to this new information.
	To test your analyzer, define the Fibonacci machine from \cref{Figure 5.12} and examine the lists you constructed.
\end{exercise}



\begin{exercise}
	\label{Exercise 5.13}
	Modify the simulator so that it uses the controller sequence to determine what registers the machine has rather than requiring a list of registers as an argument to \code{make-machine}.
	Instead of pre-allocating the registers in \code{make-machine}, you can allocate them one at a time when they are first seen during assembly of the instructions.
\end{exercise}
