\subsection{Internal Definitions}
\label{Section 4.1.6}

Our environment model of evaluation and our metacircular evaluator execute definitions in sequence, extending the environment frame one definition at a time.
This is particularly convenient for interactive program development, in which the programmer needs to freely mix the application of procedures with the definition of new procedures.
However, if we think carefully about the internal definitions used to implement block structure (introduced in \cref{Section 1.1.8}), we will find that name-by-name extension of the environment may not be the best way to define local variables.

Consider a procedure with internal definitions, such as
\begin{scheme}
  (define (f x)
    (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
    (define (odd? n)  (if (= n 0) false (even? (- n 1))))
    ⟨~\var{\dark rest of body of \code{f}}~⟩)
\end{scheme}

Our intention here is that the name \code{odd?} in the body of the procedure \code{even?} should refer to the procedure \code{odd?} that is defined after \code{even?}.
The scope of the name \code{odd?} is the entire body of \code{f}, not just the portion of the body of \code{f} starting at the point where the \code{define} for \code{odd?} occurs.
Indeed, when we consider that \code{odd?} is itself defined in terms of \code{even?}---so that \code{even?} and \code{odd?} are mutually recursive procedures---we see that the only satisfactory interpretation of the two \code{define}s is to regard them as if the names \code{even?} and \code{odd?} were being added to the environment simultaneously.
More generally, in block structure, the scope of a local name is the entire procedure body in which the \code{define} is evaluated.

As it happens, our interpreter will evaluate calls to \code{f} correctly, but for an “accidental” reason:
Since the definitions of the internal procedures come first, no calls to these procedures will be evaluated until all of them have been defined.
Hence, \code{odd?} will have been defined by the time \code{even?} is executed.
In fact, our sequential evaluation mechanism will give the same result as a mechanism that directly implements simultaneous definition for any procedure in which the internal definitions come first in a body and evaluation of the value expressions for the defined variables doesn’t actually use any of the defined variables.
(For an example of a procedure that doesn’t obey these restrictions, so that sequential definition isn’t equivalent to simultaneous definition, see \cref{Exercise 4.19}.)%
\footnote{
	Wanting programs to not depend on this evaluation mechanism is the reason for the “management is not responsible” remark in \cref{Footnote 28} of \cref{Chapter 1}.
	By insisting that internal definitions come first and do not use each other while the definitions are being evaluated, the \acronym{IEEE} standard for Scheme leaves implementors some choice in the mechanism used to evaluate these definitions.
	The choice of one evaluation rule rather than another here may seem like a small issue, affecting only the interpretation of “badly formed” programs.
	However, we will see in \cref{Section 5.5.6} that moving to a model of simultaneous scoping for internal definitions avoids some nasty difficulties that would otherwise arise in implementing a compiler.
}

There is, however, a simple way to treat definitions so that internally defined names have truly simultaneous scope---just create all local variables that will be in the current environment before evaluating any of the value expressions.
One way to do this is by a syntax transformation on \code{lambda} expressions.
Before evaluating the body of a \code{lambda} expression, we “scan out” and eliminate all the internal definitions in the body.
The internally defined variables will be created with a \code{let} and then set to their values by assignment.
For example, the procedure
\begin{scheme}
  (lambda ⟨~\var{vars}~⟩
    (define u ⟨~\var{\dark e1}~⟩)
    (define v ⟨~\var{\dark e2}~⟩)
    ⟨~\var{\dark e3}~⟩)
\end{scheme}
would be transformed into
\begin{scheme}
  (lambda ⟨~\var{vars}~⟩
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u ⟨~\var{\dark e1}~⟩)
      (set! v ⟨~\var{\dark e2}~⟩)
      ⟨~\var{\dark e3}~⟩))
\end{scheme}
where \code{*unassigned*} is a special symbol that causes looking up a variable to signal an error if an attempt is made to use the value of the not-yet-assigned variable.

An alternative strategy for scanning out internal definitions is shown in \cref{Exercise 4.18}.
Unlike the transformation shown above, this enforces the restriction that the defined variables’ values can be evaluated without using any of the variables’ values.%
\footnote{
	The \acronym{IEEE} standard for Scheme allows for different implementation strategies by specifying that it is up to the programmer to obey this restriction, not up to the implementation to enforce it.
	Some Scheme implementations, including \acronym{MIT} Scheme, use the transformation shown above.
	Thus, some programs that don’t obey this restriction will in fact run in such implementations.
}



\begin{exercise}
	\label{Exercise 4.16}
	In this exercise we implement the method just described for interpreting internal definitions.
	We assume that the evaluator supports \code{let} (see \cref{Exercise 4.6}).
	\begin{enumerate}[label = \alph*., leftmargin = *]

		\item
			Change \code{lookup-variable-value} (\cref{Section 4.1.3}) to signal an error if the value it finds is the symbol \code{*unassigned*}.

		\item
			Write a procedure \code{scan-out-defines} that takes a procedure body and returns an equivalent one that has no internal definitions, by making the transformation described above.

		\item
			Install \code{scan-out-defines} in the interpreter, either in \code{make-procedure} or in \code{procedure-body} (see \cref{Section 4.1.3}).
			Which place is better?
			Why?

	\end{enumerate}
\end{exercise}



\begin{exercise}
	\label{Exercise 4.17}
	Draw diagrams of the environment in effect when evaluating the expression \code{⟨\var{e3}⟩} in the procedure in the text, comparing how this will be structured when definitions are interpreted sequentially with how it will be structured if definitions are scanned out as described.
	Why is there an extra frame in the transformed program?
	Explain why this difference in environment structure can never make a difference in the behavior of a correct program.
	Design a way to make the interpreter implement the “simultaneous” scope rule for internal definitions without constructing the extra frame.
\end{exercise}



\begin{exercise}
	\label{Exercise 4.18} Consider an alternative strategy for scanning out definitions that translates the example in the text to
	\begin{scheme}
	  (lambda ⟨~\var{vars}~⟩
	    (let ((u '*unassigned*) (v '*unassigned*))
	      (let ((a ⟨~\var{\dark e1}~⟩) (b ⟨~\var{\dark e2}~⟩))
	        (set! u a)
	        (set! v b))
	      ⟨~\var{\dark e3}~⟩))
	\end{scheme}
	Here \code{a} and \code{b} are meant to represent new variable names, created by the interpreter, that do not appear in the user’s program.
	Consider the \code{solve} procedure from \cref{Section 3.5.4}:
	\begin{scheme}
	  (define (solve f y0 dt)
	    (define  y (integral (delay dy) y0 dt))
	    (define dy (stream-map f y))
	    y)
	\end{scheme}
	Will this procedure work if internal definitions are scanned out as shown in this exercise?
	What if they are scanned out as shown in the text?
	Explain.
\end{exercise}



\begin{exercise}
	\label{Exercise 4.19}
	Ben Bitdiddle, Alyssa~P.~Hacker, and Eva Lu Ator are arguing about the desired result of evaluating the expression
	\begin{scheme}
	  (let ((a 1))
	    (define (f x)
	      (define b (+ a x))
	      (define a 5)
	      (+ a b))
	    (f 10))
	\end{scheme}
	Ben asserts that the result should be obtained using the sequential rule for \code{define}:
	\code{b} is defined to be 11, then \code{a} is defined to be 5, so the result is 16.
	Alyssa objects that mutual recursion requires the simultaneous scope rule for internal procedure definitions, and that it is unreasonable to treat procedure names differently from other names.
	Thus, she argues for the mechanism implemented in \cref{Exercise 4.16}.
	This would lead to \code{a} being unassigned at the time that the value for \code{b} is to be computed.
	Hence, in Alyssa’s view the procedure should produce an error.
	Eva has a third opinion.
	She says that if the definitions of \code{a} and \code{b} are truly meant to be simultaneous, then the value 5 for \code{a} should be used in evaluating \code{b}.
	Hence, in Eva’s view \code{a} should be 5, \code{b} should be 15, and the result should be 20.
	Which (if any) of these viewpoints do you support?
	Can you devise a way to implement internal definitions so that they behave as Eva prefers?%
	\footnote{
		The \acronym{MIT} implementors of Scheme support Alyssa on the following grounds:
		Eva is in principle correct---the definitions should be regarded as simultaneous.
		But it seems difficult to implement a general, efficient mechanism that does what Eva requires.
		In the absence of such a mechanism, it is better to generate an error in the difficult cases of simultaneous definitions (Alyssa’s notion) than to produce an incorrect answer (as Ben would have it).
	}
\end{exercise}



\begin{exercise}
	\label{Exercise 4.20}
	Because internal definitions look sequential but are actually simultaneous, some people prefer to avoid them entirely, and use the special form \code{letrec} instead.
	\code{letrec} looks like \code{let}, so it is not surprising that the variables it binds are bound simultaneously and have the same scope as each other.
	The sample procedure \code{f} above can be written without internal definitions, but with exactly the same meaning, as
	\begin{scheme}
	  (define (f x)
	    (letrec
	      ((even? (lambda (n)
	                (if (= n 0) true  (odd?  (- n 1)))))
	       (odd?  (lambda (n)
	                (if (= n 0) false (even? (- n 1))))))
	      ⟨~\var{\dark rest of body of \code{f}}~⟩))
	\end{scheme}
	\code{letrec} expressions, which have the form
	\begin{scheme}
	  (letrec ((⟨~\var{var}\ind{1}~⟩ ⟨~\var{exp}\ind{1}~⟩) … (⟨~\var{var}\ind{n}~⟩ ⟨~\var{exp}\ind{n}~⟩))
	    ⟨~\var{body}~⟩)
	\end{scheme}
	are a variation on \code{let} in which the expressions \code{⟨\var{exp}\ind{k}⟩} that provide the initial values for the variables \code{⟨\var{var}\ind{k}⟩} are evaluated in an environment that includes all the \code{letrec} bindings.
	This permits recursion in the bindings, such as the mutual recursion of \code{even?} and \code{odd?} in the example above, or the evaluation of \( 10 \) factorial with
	\begin{scheme}
	  (letrec
	    ((fact (lambda (n)
	             (if (= n 1) 1 (* n (fact (- n 1)))))))
	    (fact 10))
	\end{scheme}

	\begin{enumerate}[label = \alph*., leftmargin = *]

		\item
			Implement \code{letrec} as a derived expression, by transforming a \code{letrec} expression into a \code{let} expression as shown in the text above or in \cref{Exercise 4.18}.
			That is, the \code{letrec} variables should be created with a \code{let} and then be assigned their values with \code{set!}.

		\item
			Louis Reasoner is confused by all this fuss about internal definitions.
			The way he sees it, if you don’t like to use \code{define} inside a procedure, you can just use \code{let}.
			Illustrate what is loose about his reasoning by drawing an environment diagram that shows the environment in which the \code{⟨\var{rest of body of \code{f}}⟩} is evaluated during evaluation of the expression \code{(f 5)}, with \code{f} defined as in this exercise.
			Draw an environment diagram for the same evaluation, but with \code{let} in place of \code{letrec} in the definition of \code{f}.

	\end{enumerate}
\end{exercise}



\begin{exercise}
	\label{Exercise 4.21}
	Amazingly, Louis’s intuition in \cref{Exercise 4.20} is correct.
	It is indeed possible to specify recursive procedures without using \code{letrec} (or even \code{define}), although the method for accomplishing this is much more subtle than Louis imagined.
	The following expression computes 10 factorial by applying a recursive factorial procedure:%
	\footnote{
		This example illustrates a programming trick for formulating recursive procedures without using \code{define}.
		The most general trick of this sort is the \( Y \) \newterm{operator}, which can be used to give a “pure λ-calculus” implementation of recursion.
		(See \cref{Stoy 1977} for details on the λ-calculus, and \cref{Gabriel 1988} for an exposition of the \( Y \) operator in Scheme.)
	}
	\begin{scheme}
	  ((lambda (n)
	     ((lambda (fact) (fact fact n))
	      (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
	   10)
	\end{scheme}
	\begin{enumerate}[label = \alph*., leftmargin = *]

		\item
			Check (by evaluating the expression) that this really does compute factorials.
			Devise an analogous expression for computing Fibonacci numbers.

		\item
			Consider the following procedure, which includes mutually recursive internal definitions:
			\begin{scheme}
			  (define (f x)
			    (define (even? n)
			      (if (= n 0) true  (odd?  (- n 1))))
			    (define (odd? n)
			      (if (= n 0) false (even? (- n 1))))
			    (even? x))
			\end{scheme}
			Fill in the missing expressions to complete an alternative definition of \code{f}, which uses neither internal definitions nor \code{letrec}:
			\begin{scheme}
			  (define (f x)
			    ((lambda (even? odd?) (even? even? odd? x))
			     (lambda (ev? od? n)
			       (if (= n 0) true (od? ⟨??⟩ ⟨??⟩ ⟨??⟩)))
			     (lambda (ev? od? n)
			       (if (= n 0) false (ev? ⟨??⟩ ⟨??⟩ ⟨??⟩)))))
			\end{scheme}

	\end{enumerate}
\end{exercise}
