\subsection{Mutable List Structure}
\label{Section 3.3.1}

The basic operations on pairs---\code{cons}, \code{car}, and \code{cdr}---can be used to construct list structure and to select parts from list structure, but they are incapable of modifying list structure.
The same is true of the list operations we have used so far, such as \code{append} and \code{list}, since these can be defined in terms of \code{cons}, \code{car}, and \code{cdr}.
To modify list structures we need new operations.

The primitive mutators for pairs are \code{set-car!} and \code{set-cdr!}.
\code{set-car!} takes two arguments, the first of which must be a pair.
It modifies this pair, replacing the \code{car} pointer by a pointer to the second argument of \code{set-car!}.%
\footnote{
	\code{set-car!} and \code{set-cdr!} return implementation-dependent values.
	Like \code{set!}, they should be used only for their effect.
}

\begin{figure}[tp]
	\centering
	\includesvg[width=72mm]{fig/chap3/Fig3.12b.svg}
	\caption{
		Lists \code{x}: \code{((a b) c d)} and \code{y}: \code{(e f)}.
	}
	\label{Figure 3.12}
\end{figure}

\begin{figure}[bp]
	\centering
	\includesvg[width=72mm]{fig/chap3/Fig3.13b.svg}
	\caption{
		Effect of \code{(set-car! x y)} on the lists in \cref{Figure 3.12}.
	}
	\label{Figure 3.13}
\end{figure}

As an example, suppose that \code{x} is bound to the list \code{((a b) c d)} and \code{y} to the list \code{(e f)} as illustrated in \cref{Figure 3.12}.
Evaluating the expression \code{ (set-car! x y)} modifies the pair to which \code{x} is bound, replacing its \code{car} by the value of \code{y}.
The result of the operation is shown in \cref{Figure 3.13}.
The structure \code{x} has been modified and would now be printed as \code{((e f) c d)}.
The pairs representing the list \code{(a b)}, identified by the pointer that was replaced, are now detached from the original structure.%
\footnote{
	We see from this that mutation operations on lists can create “garbage” that is not part of any accessible structure.
	We will see in \cref{Section 5.3.2} that Lisp memory-management systems include a \newterm{garbage collector}, which identifies and recycles the memory space used by unneeded pairs.
}

\begin{figure}[tp]
	\centering
	\includesvg[width=72mm]{fig/chap3/Fig3.14b.svg}
	\caption{
		Effect of \code{(define z (cons y (cdr x)))} on the lists in \cref{Figure 3.12}.
	}
	\label{Figure 3.14}
\end{figure}

Compare \cref{Figure 3.13} with \cref{Figure 3.14}, which illustrates the result of executing \code{(define z (cons y (cdr x)))} with \code{x} and \code{y} bound to the original lists of \cref{Figure 3.12}.
The variable \code{z} is now bound to a new pair created by the \code{cons} operation;
the list to which \code{x} is bound is unchanged.

\begin{figure}[bp]
	\centering
	\includesvg[width=72mm]{fig/chap3/Fig3.15b.svg}
	\caption{
		Effect of \code{(set-cdr! x y)} on the lists in \cref{Figure 3.12}.
	}
	\label{Figure 3.15}
\end{figure}

The \code{set-cdr!} operation is similar to \code{set-car!}.
The only difference is that the \code{cdr} pointer of the pair, rather than the \code{car} pointer, is replaced.
The effect of executing \code{(set-cdr! x y)} on the lists of \cref{Figure 3.12} is shown in \cref{Figure 3.15}.
Here the \code{cdr} pointer of \code{x} has been replaced by the pointer to \code{(e f)}.
Also, the list \code{(c d)}, which used to be the \code{cdr} of \code{x}, is now detached from the structure.

\code{cons} builds new list structure by creating new pairs, while \code{set-car!} and \code{set-cdr!} modify existing pairs.
Indeed, we could implement \code{cons} in terms of the two mutators, together with a procedure \code{get-new-pair}, which returns a new pair that is not part of any existing list structure.
We obtain the new pair, set its \code{car} and \code{cdr} pointers to the designated objects, and return the new pair as the result of the \code{cons}.%
\footnote{
	\code{get-new-pair} is one of the operations that must be implemented as part of the memory management required by a Lisp implementation.
	We will discuss this in \cref{Section 5.3.1}.
}
\begin{scheme}
  (define (cons x y)
    (let ((new (get-new-pair)))
      (set-car! new x)
      (set-cdr! new y)
      new))
\end{scheme}



\begin{exercise}
	\label{Exercise 3.12}
	The following procedure for appending lists was introduced in \cref{Section 2.2.1}:
	\begin{scheme}
	  (define (append x y)
	    (if (null? x)
	        y
	        (cons (car x) (append (cdr x) y))))
	\end{scheme}
	\code{append} forms a new list by successively \code{cons}ing the elements of \code{x} onto \code{y}.
	The procedure \code{append!} is similar to \code{append}, but it is a mutator rather than a constructor.
	It appends the lists by splicing them together, modifying the final pair of \code{x} so that its \code{cdr} is now \code{y}.
	(It is an error to call \code{append!} with an empty \code{x}.)
	\begin{scheme}
	  (define (append! x y)
	    (set-cdr! (last-pair x) y)
	    x)
	\end{scheme}
	Here \code{last-pair} is a procedure that returns the last pair in its argument:
	\begin{scheme}
	  (define (last-pair x)
	  (if (null? (cdr x)) x (last-pair (cdr x))))
	\end{scheme}
	Consider the interaction
	\begin{scheme}
	  (define x (list 'a 'b))

	  (define y (list 'c 'd))

	  (define z (append x y))

	  z
	  ~\outprint{(a b c d)}~

	  (cdr x)
	  ⟨~\var{response}~⟩

	  (define w (append! x y))

	  w
	  ~\outprint{(a b c d)}~

	  (cdr x)
	  ⟨~\var{response}~⟩
	\end{scheme}
	What are the missing ⟨\var{response}⟩s?
	Draw box-and-pointer diagrams to explain your answer.
\end{exercise}



\begin{exercise}
	\label{Exercise 3.13}
	Consider the following \code{make-cycle} procedure, which uses the \code{last-pair} procedure defined in \cref{Exercise 3.12}:
	\begin{scheme}
	  (define (make-cycle x)
	    (set-cdr! (last-pair x) x)
	    x)
	\end{scheme}
	Draw a box-and-pointer diagram that shows the structure \code{z} created by
	\begin{scheme}
	  (define z (make-cycle (list 'a 'b 'c)))
	\end{scheme}
	What happens if we try to compute \code{(last-pair z)}?
\end{exercise}



\begin{exercise}
	\label{Exercise 3.14}
	The following procedure is quite useful, although obscure:
	\begin{scheme}
	  (define (mystery x)
	    (define (loop x y)
	      (if (null? x)
	          y
	          (let ((temp (cdr x)))
	            (set-cdr! x y)
	            (loop temp x))))
	    (loop x '()))
	\end{scheme}
	\code{loop} uses the “temporary” variable \code{temp} to hold the old value of the \code{cdr} of \code{x}, since the \code{set-cdr!}  on the next line destroys the \code{cdr}.
	Explain what \code{mystery} does in general.
	Suppose \code{v} is defined by \code{(define v (list 'a 'b 'c 'd))}.
	Draw the box-and-pointer diagram that represents the list to which \code{v} is bound.
	Suppose that we now evaluate \code{(define w (mystery v))}.
	Draw box-and-pointer diagrams that show the structures \code{v} and \code{w} after evaluating this expression.
	What would be printed as the values of \code{v} and \code{w}?
\end{exercise}



\subsubsection*{Sharing and identity}

We mentioned in \cref{Section 3.1.3} the theoretical issues of “sameness” and “change” raised by the introduction of assignment.
These issues arise in practice when individual pairs are \newterm{shared} among different data objects.
For example, consider the structure formed by
\begin{scheme}
  (define x (list 'a 'b))
  (define z1 (cons x x))
\end{scheme}
As shown in \cref{Figure 3.16}, \code{z1} is a pair whose \code{car} and \code{cdr} both point to the same pair \code{x}.
This sharing of \code{x} by the \code{car} and \code{cdr} of \code{z1} is a consequence of the straightforward way in which \code{cons} is implemented.
In general, using \code{cons} to construct lists will result in an interlinked structure of pairs in which many individual pairs are shared by many different structures.

In contrast to \cref{Figure 3.16}, \cref{Figure 3.17} shows the structure created by
\begin{scheme}
  (define z2 (cons (list 'a 'b) (list 'a 'b)))
\end{scheme}
In this structure, the pairs in the two \code{(a b)} lists are distinct, although the actual symbols are shared.%
\footnote{
	The two pairs are distinct because each call to \code{cons} returns a new pair.
	The symbols are shared;
	in Scheme there is a unique symbol with any given name.
	Since Scheme provides no way to mutate a symbol, this sharing is undetectable.
	Note also that the sharing is what enables us to compare symbols using \code{eq?}, which simply checks equality of pointers
.}

\begin{figure}[tb]
	\centering
	\includesvg[width=46mm]{fig/chap3/Fig3.16b.svg}
	\caption{
		The list \code{z1} formed by \code{(cons x x)}.
	}
	\label{Figure 3.16}
\end{figure}

\begin{figure}[tb]
	\centering
	\includesvg[width=71mm]{fig/chap3/Fig3.17b.svg}
	\caption{
		The list \code{z2} formed by \code{(cons (list 'a 'b) (list 'a 'b))}.
	}
	\label{Figure 3.17}
\end{figure}

When thought of as a list, \code{z1} and \code{z2} both represent “the same” list, \code{((a b) a b)}.
In general, sharing is completely undetectable if we operate on lists using only \code{cons}, \code{car}, and \code{cdr}.
However, if we allow mutators on list structure, sharing becomes significant.
As an example of the difference that sharing can make, consider the following procedure, which modifies the \code{car} of the structure to which it is applied:
\begin{scheme}
  (define (set-to-wow! x) (set-car! (car x) 'wow) x)
\end{scheme}
Even though \code{z1} and \code{z2} are “the same” structure, applying
\code{set-to-wow!} to them yields different results.  With \code{z1}, altering
the \code{car} also changes the \code{cdr}, because in \code{z1} the \code{car}
and the \code{cdr} are the same pair.  With \code{z2}, the \code{car} and
\code{cdr} are distinct, so \code{set-to-wow!} modifies only the \code{car}:
\begin{scheme}
	z1
	~\outprint{((a b) a b)}~

	(set-to-wow! z1)
	~\outprint{((wow b) wow b)}~

	z2
	~\outprint{((a b) a b)}~

	(set-to-wow! z2)
	~\outprint{((wow b) a b)}~
\end{scheme}

One way to detect sharing in list structures is to use the predicate \code{eq?}, which we introduced in \cref{Section 2.3.1} as a way to test whether two symbols are equal.
More generally, \code{(eq? x y)} tests whether \code{x} and \code{y} are the same object (that is, whether \code{x} and \code{y} are equal as pointers).
Thus, with \code{z1} and \code{z2} as defined in \cref{Figure 3.16} and \cref{Figure 3.17}, \code{(eq? (car z1) (cdr z1))} is true and \code{(eq? (car z2) (cdr z2))} is false.

As will be seen in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs.
On the other hand, sharing can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts.
The mutation operations \code{set-car!} and \code{set-cdr!} should be used with care;
unless we have a good understanding of how our data objects are shared, mutation can have unanticipated results.%
\footnote{
	The subtleties of dealing with sharing of mutable data objects reflect the underlying issues of “sameness”  and  “change” that were raised in \cref{Section 3.1.3}.
	We mentioned there that admitting change to our language requires that a compound object must have an “identity” that is something different from the pieces from which it is composed.
	In Lisp, we consider this “identity” to be the quality that is tested by \code{eq?}, i.e., by equality of pointers.
	Since in most Lisp implementations a pointer is essentially a memory address, we are “solving the problem” of defining the identity of objects by stipulating that a data object “itself” is the information stored in some particular set of memory locations in the computer.
	This suffices for simple Lisp programs, but is hardly a general way to resolve the issue of “sameness” in computational models.
}



\begin{exercise}
	\label{Exercise 3.15}
	Draw box-and-pointer diagrams to explain the effect of \code{set-to-wow!} on the structures \code{z1} and \code{z2} above.
\end{exercise}



\begin{exercise}
	\label{Exercise 3.16}
	Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure.
	“It’s easy,” he reasons.
	“The number of pairs in any structure is the number in the \code{car} plus the number in the \code{cdr} plus one more to count the current pair.”
	So Ben writes the following procedure:
	\begin{scheme}
	  (define (count-pairs x)
	    (if (not (pair? x))
	        0
	        (+ (count-pairs (car x))
	           (count-pairs (cdr x))
	           1)))
	\end{scheme}
	Show that this procedure is not correct.
	In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben’s procedure would return 3;
	return 4;
	return 7;
	never return at all.
\end{exercise}



\begin{exercise}
	\label{Exercise 3.17}
	Devise a correct version of the \code{count-pairs} procedure of \cref{Exercise 3.16} that returns the number of distinct pairs in any structure.
	(Hint:
	Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)
\end{exercise}



\begin{exercise}
	\label{Exercise 3.18} Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive \code{cdr}s would go into an infinite loop.
	\cref{Exercise 3.13} constructed such lists.
\end{exercise}



\begin{exercise}
	\label{Exercise 3.19}
	Redo \cref{Exercise 3.18} using an algorithm that takes only a constant amount of space.
	(This requires a very clever idea.)
\end{exercise}



\subsubsection*{Mutation is just assignment}

When we introduced compound data, we observed in \cref{Section 2.1.3} that pairs can be represented purely in terms of procedures:
\begin{scheme}
  (define (cons x y)
    (define (dispatch m)
      (cond ((eq? m 'car) x)
            ((eq? m 'cdr) y)
            (else (error "Undefined operation: CONS" m))))
    dispatch)
  (define (car z) (z 'car))
  (define (cdr z) (z 'cdr))
\end{scheme}
The same observation is true for mutable data.
We can implement mutable data objects as procedures using assignment and local state.
For instance, we can extend the above pair implementation to handle \code{set-car!} and \code{set-cdr!} in a manner analogous to the way we implemented bank accounts using \code{make-account} in \cref{Section 3.1.1}:
\begin{scheme}
  (define (cons x y)
    (define (set-x! v) (set! x v))
    (define (set-y! v) (set! y v))
    (define (dispatch m)
      (cond ((eq? m 'car) x)
            ((eq? m 'cdr) y)
            ((eq? m 'set-car!) set-x!)
            ((eq? m 'set-cdr!) set-y!)
            (else
             (error "Undefined operation: CONS" m))))
    dispatch)
  (define (car z) (z 'car))
  (define (cdr z) (z 'cdr))
  (define (set-car! z new-value)
    ((z 'set-car!) new-value) z)
  (define (set-cdr! z new-value)
    ((z 'set-cdr!) new-value) z)
\end{scheme}

Assignment is all that is needed, theoretically, to account for the behavior of mutable data.
As soon as we admit \code{set!} to our language, we raise all the issues, not only of assignment, but of mutable data in general.%
\footnote{
	On the other hand, from the viewpoint of implementation, assignment requires us to modify the environment, which is itself a mutable data structure.
	Thus, assignment and mutation are equipotent:
	Each can be implemented in terms of the other.
}



\begin{exercise}
	\label{Exercise 3.20}
	Draw environment diagrams to illustrate the evaluation of the sequence of expressions
	\begin{scheme}
	  (define x (cons 1 2))
	  (define z (cons x x))
	  (set-car! (cdr z) 17)
	  (car x)
	  ~\outprint{17}~
	\end{scheme}
	using the procedural implementation of pairs given above.
	(Compare \cref{Exercise 3.11}.)
\end{exercise}
