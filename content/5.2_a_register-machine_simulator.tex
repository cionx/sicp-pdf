\section{A Register-Machine Simulator}
\label{Section 5.2}

In order to gain a good understanding of the design of register machines, we must test the machines we design to see if they perform as expected.
One way to test a design is to hand-simulate the operation of the controller, as in \cref{Exercise 5.5}.
But this is extremely tedious for all but the simplest machines.
In this section we construct a simulator for machines described in the register-machine language.
The simulator is a Scheme program with four interface procedures.
The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:

\begin{itemize}

	\item
		\begin{scheme}
		  (make-machine ⟨~\var{\dark register-names}~⟩ ⟨~\var{operations}~⟩ ⟨~\var{controller}~⟩)
		\end{scheme}
		constructs and returns a model of the machine with the given registers, operations, and controller.

	\item
		\begin{scheme}
		  (set-register-contents! ⟨~\var{\dark machine-model}~⟩
		                          ⟨~\var{\dark register-name}~⟩
		                          ⟨~\var{value}~⟩)
		\end{scheme}
		stores a value in a simulated register in the given machine.

	\item
		\begin{scheme}
		  (get-register-contents ⟨~\var{\dark machine-model}~⟩ ⟨~\var{\dark register-name}~⟩)
		\end{scheme}
		returns the contents of a simulated register in the given machine.

	\item
		\begin{scheme}
		  (start ⟨~\var{\dark machine-model}~⟩)
		\end{scheme}
		simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence.

\end{itemize}

As an example of how these procedures are used, we can define \code{gcd-machine} to be a model of the \acronym{GCD} machine of \cref{Section 5.1.1} as follows:
\begin{scheme}
  (define gcd-machine
    (make-machine
     '(a b t)
     (list (list 'rem remainder) (list '= =))
     '(test-b (test (op =) (reg b) (const 0))
              (branch (label gcd-done))
              (assign t (op rem) (reg a) (reg b))
              (assign a (reg b))
              (assign b (reg t))
              (goto (label test-b))
              gcd-done)))
\end{scheme}
The first argument to \code{make-machine} is a list of register names.
The next argument is a table (a list of two-element lists) that pairs each operation name with a Scheme procedure that implements the operation (that is, produces the same output value given the same input values).
The last argument specifies the controller as a list of labels and machine instructions, as in \cref{Section 5.1}.

To compute \acronym{GCD}s with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates:
\begin{scheme}
  (set-register-contents! gcd-machine 'a 206)
  ~\outprint{done}~

  (set-register-contents! gcd-machine 'b 40)
  ~\outprint{done}~

  (start gcd-machine)
  ~\outprint{done}~

  (get-register-contents gcd-machine 'a)
  ~\outprint{2}~
\end{scheme}
This computation will run much more slowly than a \code{gcd} procedure written in Scheme, because we will simulate low-level machine instructions, such as \code{assign}, by much more complex operations.



\begin{exercise}
	\label{Exercise 5.7}
	Use the simulator to test the machines you designed in \cref{Exercise 5.4}.
\end{exercise}



\input{content/5.2.1_the_machine_model.tex}
\input{content/5.2.2_the_assembler.tex}
\input{content/5.2.3_generating_execution_procedures_for_instructions.tex}
\input{content/5.2.4_monitoring_machine_performance.tex}
