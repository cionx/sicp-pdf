\subsection{Internal Definitions}
\label{Section 3.2.4}

\link{Section 1.1.8} introduced the idea that procedures can have internal definitions, thus leading to a block structure as in the following procedure to compute square roots:
\begin{scheme}
  (define (sqrt x)
    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))
    (define (improve guess)
      (average guess (/ x guess)))
    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))
\end{scheme}
Now we can use the environment model to see why these internal definitions behave as desired.
\link{Figure 3.11} shows the point in the evaluation of the expression \code{(sqrt 2)} where the internal procedure \code{good-enough?} has been called for the first time with \code{guess} equal to \( 1 \).

Observe the structure of the environment.
\code{sqrt} is a symbol in the global environment that is bound to a procedure object whose associated environment is the global environment.
When \code{sqrt} was called, a new environment E1 was formed, subordinate to the global environment, in which the parameter \code{x} is bound to \( 2 \).
The body of \code{sqrt} was then evaluated in E1.
Since the first expression in the body of \code{sqrt} is
\begin{scheme}
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
\end{scheme}
evaluating this expression defined the procedure \code{good-enough?}  in the environment E1.
To be more precise, the symbol \code{good-enough?} was added to the first frame of E1, bound to a procedure object whose associated environment is E1.
Similarly, \code{improve} and \code{sqrt-iter} were defined as procedures in E1.
For conciseness, \link{Figure 3.11} shows only the procedure object for \code{good-enough?}.

\begin{figure}[tb]
	\centering
	\includesvg[width=107mm]{fig/chap3/Fig3.11a.svg}
	\caption{
		\code{sqrt} procedure with internal definitions.
	}
	\label{Figure 3.11}
\end{figure}

After the local procedures were defined, the expression \code{(sqrt-iter 1.0)} was evaluated, still in environment E1.
So the procedure object bound to \code{sqrt-iter} in E1 was called with \( 1 \) as an argument.
This created an environment E2 in which \code{guess}, the parameter of \code{sqrt-iter}, is bound to \( 1 \).
\code{sqrt-iter} in turn called \code{good-enough?} with the value of \code{guess} (from E2) as the argument for \code{good-enough?}.
This set up another environment, E3, in which \code{guess} (the parameter of \code{good-enough?}) is bound to \( 1 \).
Although \code{sqrt-iter} and \code{good-enough?} both have a parameter named \code{guess}, these are two distinct local variables located in different frames.
Also, E2 and E3 both have E1 as their enclosing environment, because the \code{sqrt-iter} and \code{good-enough?} procedures both have E1 as their environment part.
One consequence of this is that the symbol \code{x} that appears in the body of \code{good-enough?} will reference the binding of \code{x} that appears in E1, namely the value of \code{x} with which the original \code{sqrt} procedure was called.

The environment model thus explains the two key properties that make local procedure definitions a useful technique for modularizing programs:
\begin{itemize}

	\item
		The names of the local procedures do not interfere with names external to the enclosing procedure, because the local procedure names will be bound in the frame that the procedure creates when it is run, rather than being bound in the global environment.

	\item
		The local procedures can access the arguments of the enclosing procedure, simply by using parameter names as free variables.
		This is because the body of the local procedure is evaluated in an environment that is subordinate to the evaluation environment for the enclosing procedure.

\end{itemize}



\begin{exercise}
	\label{Exercise 3.11}
	In \link{Section 3.2.3} we saw how the environment model described the behavior of procedures with local state.
	Now we have seen how internal definitions work.
	A typical message-passing procedure contains both of these aspects.
	Consider the bank account procedure of \link{Section 3.1.1}:
	\begin{scheme}
	  (define (make-account balance)
	    (define (withdraw amount)
	      (if (>= balance amount)
	          (begin (set! balance (- balance amount))
	                 balance)
	          "Insufficient funds"))
	    (define (deposit amount)
	      (set! balance (+ balance amount))
	      balance)
	    (define (dispatch m)
	      (cond ((eq? m 'withdraw) withdraw)
	            ((eq? m 'deposit) deposit)
	            (else
	             (error "Unknown request: MAKE-ACCOUNT"
	                    m))))
	    dispatch)
	\end{scheme}
	Show the environment structure generated by the sequence of interactions
	\begin{scheme}
	  (define acc (make-account 50))

	  ((acc 'deposit) 40)
	  ~\outprint{90}~

	  ((acc 'withdraw) 60)
	  ~\outprint{30}~
	\end{scheme}
	Where is the local state for \code{acc} kept?
	Suppose we define another account
	\begin{scheme}
	  (define acc2 (make-account 100))
	\end{scheme}
	How are the local states for the two accounts kept distinct?
	Which parts of the environment structure are shared between \code{acc} and \code{acc2}?
\end{exercise}
