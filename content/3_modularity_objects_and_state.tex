\chapter{Modularity, Objects, and State}
\label{Chapter 3}

% \vspace{0.5em}

\begin{quote}
Mεταβάλλον ὰναπαύεται\\
(Even while it changes, it stands still.)\\
---Heraclitus
\end{quote}

\begin{quote}
Plus \c{c}a change, plus c'est la m\^{e}me chose.\\
---Alphonse Karr
\end{quote}

% \vspace{1.0em}

\noindent
\lettrine{T}{he preceding chapters} introduced the basic elements from which programs are
made.  We saw how primitive procedures and primitive data are combined to
construct compound entities, and we learned that abstraction is vital in
helping us to cope with the complexity of large systems.  But these tools are
not sufficient for designing programs.  Effective program synthesis also
requires organizational principles that can guide us in formulating the overall
design of a program.  In particular, we need strategies to help us structure
large systems so that they will be \newterm{modular}, that is, so that they can
be divided ``naturally'' into coherent parts that can be separately developed
and maintained.

One powerful design strategy, which is particularly appropriate to the
construction of programs for modeling physical systems, is to base the
structure of our programs on the structure of the system being modeled.  For
each object in the system, we construct a corresponding computational object.
For each system action, we define a symbolic operation in our computational
model.  Our hope in using this strategy is that extending the model to
accommodate new objects or new actions will require no strategic changes to the
program, only the addition of the new symbolic analogs of those objects or
actions.  If we have been successful in our system organization, then to add a
new feature or debug an old one we will have to work on only a localized part
of the system.

To a large extent, then, the way we organize a large program is dictated by our
perception of the system to be modeled.  In this chapter we will investigate
two prominent organizational strategies arising from two rather different
``world views'' of the structure of systems.  The first organizational strategy
concentrates on \newterm{objects}, viewing a large system as a collection of
distinct objects whose behaviors may change over time.  An alternative
organizational strategy concentrates on the \newterm{streams} of information
that flow in the system, much as an electrical engineer views a
signal-processing system.

Both the object-based approach and the stream-processing approach raise
significant linguistic issues in programming.  With objects, we must be
concerned with how a computational object can change and yet maintain its
identity.  This will force us to abandon our old substitution model of
computation (\link{Section 1.1.5}) in favor of a more mechanistic but less
theoretically tractable \newterm{environment model} of computation.  The
difficulties of dealing with objects, change, and identity are a fundamental
consequence of the need to grapple with time in our computational models.
These difficulties become even greater when we allow the possibility of
concurrent execution of programs.  The stream approach can be most fully
exploited when we decouple simulated time in our model from the order of the
events that take place in the computer during evaluation.  We will accomplish
this using a technique known as \newterm{delayed evaluation}.


\input{content/3.1_assignment_and_local_state}
\input{content/3.2_the_environment_model_of_evaluation}
\input{content/3.3_modeling_with_mutable_data}
\input{content/3.4_concurrency_time_is_of_the_essence}
\input{content/3.5_streams}
