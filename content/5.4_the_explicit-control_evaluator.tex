\section{The Explicit-Control Evaluator}
\label{Section 5.4}

In \cref{Section 5.1} we saw how to transform simple Scheme programs into descriptions of register machines.
We will now perform this transformation on a more complex program, the metacircular evaluator of \cref{Section 4.1.1}--\cref{Section 4.1.4}, which shows how the behavior of a Scheme interpreter can be described in terms of the procedures \code{eval} and \code{apply}.
The \newterm{explicit-control evaluator} that we develop in this section shows how the underlying procedure-calling and argument-passing mechanisms used in the evaluation process can be described in terms of operations on registers and stacks.
In addition, the explicit-control evaluator can serve as an implementation of a Scheme interpreter, written in a language that is very similar to the native machine language of conventional computers.
The evaluator can be executed by the register-machine simulator of \cref{Section 5.2}.
Alternatively, it can be used as a starting point for building a machine-language implementation of a Scheme evaluator, or even a special-purpose machine for evaluating Scheme expressions.
\cref{Figure 5.16} shows such a hardware implementation:
a silicon chip that acts as an evaluator for Scheme.
The chip designers started with the data-path and controller specifications for a register machine similar to the evaluator described in this section and used design automation programs to construct the integrated-circuit layout.%
\footnote{
	See \cref{Batali et al. 1982} for more information on the chip and the method by which it was designed.
}

\begin{figure}[tb]
	\centering
	\includegraphics[width=91mm]{fig/chap5/chip.jpg}
	\caption{
		A silicon-chip implementation of an evaluator for Scheme.
	}
	\label{Figure 5.16}
\end{figure}



\subsubsection*{Registers and operations}

In designing the explicit-control evaluator, we must specify the operations to be used in our register machine.
We described the metacircular evaluator in terms of abstract syntax, using procedures such as \code{quoted?} and \code{make-procedure}.
In implementing the register machine, we could expand these procedures into sequences of elementary list-structure memory operations, and implement these operations on our register machine.
However, this would make our evaluator very long, obscuring the basic structure with details.
To clarify the presentation, we will include as primitive operations of the register machine the syntax procedures given in \cref{Section 4.1.2} and the procedures for representing environments and other run-time data given in sections \cref{Section 4.1.3} and \cref{Section 4.1.4}.
In order to completely specify an evaluator that could be programmed in a low-level machine language or implemented in hardware, we would replace these operations by more elementary operations, using the list-structure implementation we described in \cref{Section 5.3}.

Our Scheme evaluator register machine includes a stack and seven registers:
\code{exp}, \code{env}, \code{val}, \code{continue}, \code{proc}, \code{argl}, and \code{unev}.
\code{exp} is used to hold the expression to be evaluated, and \code{env} contains the environment in which the evaluation is to be performed.
At the end of an evaluation, \code{val} contains the value obtained by evaluating the expression in the designated environment.
The \code{continue} register is used to implement recursion, as explained in \cref{Section 5.1.4}.
(The evaluator needs to call itself recursively, since evaluating an expression requires evaluating its subexpressions.)
The registers \code{proc}, \code{argl}, and \code{unev} are used in evaluating combinations.

We will not provide a data-path diagram to show how the registers and operations of the evaluator are connected, nor will we give the complete list of machine operations.
These are implicit in the evaluatorâ€™s controller, which will be presented in detail.

\input{content/5.4.1_the_core_of_the_explicit-control_evaluator.tex}
\input{content/5.4.2_sequence_evaluation_and_tail_recursion.tex}
\input{content/5.4.3_conditionals_assignments_and_definitions.tex}
\input{content/5.4.4_running_the_evaluator.tex}
