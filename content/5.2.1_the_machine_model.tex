\subsection{The Machine Model}
\label{Section 5.2.1}

The machine model generated by \code{make-machine} is represented as a procedure with local state using the message-passing techniques developed in \link{Chapter 3}.
To build this model, \code{make-machine} begins by calling the procedure \code{make-new-machine} to construct the parts of the machine model that are common to all register machines.
This basic machine model constructed by \code{make-new-machine} is essentially a container for some registers and a stack, together with an execution mechanism that processes the controller instructions one by one.

\code{make-machine} then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined.
First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine.
Then it uses an \newterm{assembler} (described below in \link{Section 5.2.2}) to transform the controller list into instructions for the new machine and installs these as the machine’s instruction sequence.
\code{make-machine} returns as its value the modified machine model.

\begin{scheme}
  (define (make-machine register-names ops controller-text)
    (let ((machine (make-new-machine)))
      (for-each
       (lambda (register-name)
         ((machine 'allocate-register) register-name))
       register-names)
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))
\end{scheme}



\subsubsection*{Registers}

We will represent a register as a procedure with local state, as in \link{Chapter 3}.
The procedure \code{make-register} creates a register that holds a value that can be accessed or changed:
\begin{scheme}
  (define (make-register name)
    (let ((contents '*unassigned*))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              (else
               (error "Unknown request: REGISTER" message))))
      dispatch))
\end{scheme}
The following procedures are used to access registers:

\begin{scheme}
  (define (get-contents register) (register 'get))
  (define (set-contents! register value)
    ((register 'set) value))
\end{scheme}



\subsubsection*{The stack}

We can also represent a stack as a procedure with local state.
The procedure \code{make-stack} creates a stack whose local state consists of a list of the items on the stack.
A stack accepts requests to \code{push} an item onto the stack, to \code{pop} the top item off the stack and return it, and to \code{initialize} the stack to empty.

\begin{scheme}
  (define (make-stack)
    (let ((s '()))
      (define (push x) (set! s (cons x s)))
      (define (pop)
        (if (null? s)
            (error "Empty stack: POP")
            (let ((top (car s)))
              (set! s (cdr s))
              top)))
      (define (initialize)
        (set! s '())
        'done)
      (define (dispatch message)
        (cond ((eq? message 'push) push)
              ((eq? message 'pop) (pop))
              ((eq? message 'initialize) (initialize))
              (else (error "Unknown request: STACK" message))))
      dispatch))
\end{scheme}
The following procedures are used to access stacks:
\begin{scheme}
  (define (pop stack) (stack 'pop))

  (define (push stack value) ((stack 'push) value))
\end{scheme}



\subsubsection*{The basic machine}

The \code{make-new-machine} procedure, shown in \link{Figure 5.13}, constructs an object whose local state consists of a stack, an initially empty instruction sequence, a list of operations that initially contains an operation to initialize the stack, and a \newterm{register table} that initially contains two registers, named \code{flag} and \code{pc} (for “program counter”).
The internal procedure \code{allocate-register} adds new entries to the register table, and the internal procedure \code{lookup-register} looks up registers in the table.

The \code{flag} register is used to control branching in the simulated machine.
\code{test} instructions set the contents of \code{flag} to the result of the test (true or false).
\code{branch} instructions decide whether or not to branch by examining the contents of \code{flag}.

The \code{pc} register determines the sequencing of instructions as the machine runs.
This sequencing is implemented by the internal procedure \code{execute}.
In the simulation model, each machine instruction is a data structure that includes a procedure of no arguments, called the \newterm{instruction execution procedure}, such that calling this procedure simulates executing the instruction.
As the simulation runs, \code{pc} points to the place in the instruction sequence beginning with the next instruction to be executed.
\code{execute} gets that instruction, executes it by calling the instruction execution procedure, and repeats this cycle until there are no more instructions to execute (i.e., until \code{pc} points to the end of the instruction sequence).

\begin{figure}
	\centering
	\begin{scheme}
	  (define (make-new-machine)
	    (let ((pc (make-register 'pc))
	          (flag (make-register 'flag))
	          (stack (make-stack))
	          (the-instruction-sequence '()))
	      (let ((the-ops
	             (list (list 'initialize-stack
	                         (lambda () (stack 'initialize)))))
	            (register-table
	             (list (list 'pc pc) (list 'flag flag))))
	        (define (allocate-register name)
	          (if (assoc name register-table)
	              (error "Multiply defined register: " name)
	              (set! register-table
	                    (cons (list name (make-register name))
	                          register-table)))
	          'register-allocated)
	        (define (lookup-register name)
	          (let ((val (assoc name register-table)))
	            (if val
	                (cadr val)
	                (error "Unknown register:" name))))
	        (define (execute)
	          (let ((insts (get-contents pc)))
	            (if (null? insts)
	                'done
	                (begin
	                  ((instruction-execution-proc (car insts)))
	                  (execute)))))
	        (define (dispatch message)
	          (cond ((eq? message 'start)
	                 (set-contents! pc the-instruction-sequence)
	                 (execute))
	                ((eq? message 'install-instruction-sequence)
	                 (lambda (seq)
	                   (set! the-instruction-sequence seq)))
	                ((eq? message 'allocate-register)
	                 allocate-register)
	                ((eq? message 'get-register)
	                 lookup-register)
	                ((eq? message 'install-operations)
	                 (lambda (ops)
	                   (set! the-ops (append the-ops ops))))
	                ((eq? message 'stack) stack)
	                ((eq? message 'operations) the-ops)
	                (else (error "Unknown request: MACHINE"
	                             message))))
	        dispatch)))
	\end{scheme}
	\caption{
		The \code{make-new-machine} procedure, which implements the basic machine model.
	}
	\label{Figure 5.13}
\end{figure}

As part of its operation, each instruction execution procedure modifies \code{pc} to indicate the next instruction to be executed.
\code{branch} and \code{goto} instructions change \code{pc} to point to the new destination.
All other instructions simply advance \code{pc}, making it point to the next instruction in the sequence.
Observe that each call to \code{execute} calls \code{execute} again, but this does not produce an infinite loop because running the instruction execution procedure changes the contents of \code{pc}.

\code{make-new-machine} returns a \code{dispatch} procedure that implements message-passing access to the internal state.
Notice that starting the machine is accomplished by setting \code{pc} to the beginning of the instruction sequence and calling \code{execute}.

For convenience, we provide an alternate procedural interface to a machine’s \code{start} operation, as well as procedures to set and examine register contents, as specified at the beginning of \link{Section 5.2}:
\begin{scheme}
  (define (start machine) (machine 'start))

  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))

  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name)
                   value)
    'done)
\end{scheme}

These procedures (and many procedures in \link{Section 5.2.2} and \link{Section 5.2.3})
use the following to look up the register with a given name in a given machine:
\begin{scheme}
  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))
\end{scheme}
