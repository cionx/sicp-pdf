\subsection{Applying Simple Procedures}
\label{Section 3.2.2}

When we introduced the substitution model in \cref{Section 1.1.5} we showed how the combination \code{(f 5)} evaluates to 136, given the following procedure definitions:
\begin{scheme}
  (define (square x)
    (* x x))

  (define (sum-of-squares x y)
    (+ (square x) (square y)))

  (define (f a)
    (sum-of-squares (+ a 1) (* a 2)))
\end{scheme}
We can analyze the same example using the environment model.
\cref{Figure 3.4} shows the three procedure objects created by evaluating the definitions of \code{f}, \code{square}, and \code{sum-of-squares} in the global environment.
Each procedure object consists of some code, together with a pointer to the global environment.

\begin{figure}[tb]
	\centering
	\includesvg[width=106mm]{fig/chap3/Fig3.4a.svg}
	\caption{
		Procedure objects in the global frame.
	}
	\label{Figure 3.4}
\end{figure}

In \cref{Figure 3.5} we see the environment structure created by evaluating the expression \code{(f 5)}.
The call to \code{f} creates a new environment E1 beginning with a frame in which \code{a}, the formal parameter of \code{f}, is bound to the argument \( 5 \).
In E1, we evaluate the body of \code{f}:
\begin{scheme}
  (sum-of-squares (+ a 1) (* a 2))
\end{scheme}
To evaluate this combination, we first evaluate the subexpressions.
The first subexpression, \code{sum-of-squares}, has a value that is a procedure object.
(Notice how this value is found:
We first look in the first frame of E1, which contains no binding for \code{sum-of-squares}.
Then we proceed to the enclosing environment, i.e., the global environment, and find the binding shown in \cref{Figure 3.4}.)
The other two subexpressions are evaluated by applying the primitive operations \code{+} and \code{*} to evaluate the two combinations \code{(+ a 1)} and \code{(* a 2)} to obtain \( 6 \) and \( 10 \), respectively.

Now we apply the procedure object \code{sum-of-squares} to the arguments \( 6 \) and \( 10 \).
This results in a new environment E2 in which the formal parameters \code{x} and \code{y} are bound to the arguments.
Within E2 we evaluate the combination \code{(+ (square x) (square y))}.
This leads us to evaluate \code{(square x)}, where \code{square} is found in the global frame and \code{x} is \( 6 \).
Once again, we set up a new environment, E3, in which \code{x} is bound to \( 6 \), and within this we evaluate the body of \code{square}, which is \code{(* x x)}.
Also as part of applying \code{sum-of-squares}, we must evaluate the subexpression \code{(square y)}, where \code{y} is 10.
This second call to \code{square} creates another environment, E4, in which \code{x}, the formal parameter of \code{square}, is bound to 10.
And within E4 we must evaluate \code{(* x x)}.

\begin{figure}[tb]
	\centering
	\includesvg[width=100mm]{fig/chap3/Fig3.5a.svg}
	\caption{
		Environments created by evaluating \code{(f 5)} using the procedures in \cref{Figure 3.4}.
	}
	\label{Figure 3.5}
\end{figure}

The important point to observe is that each call to \code{square} creates a new environment containing a binding for \code{x}.
We can see here how the different frames serve to keep separate the different local variables all named \code{x}.
Notice that each frame created by \code{square} points to the global environment, since this is the environment indicated by the \code{square} procedure object.

After the subexpressions are evaluated, the results are returned.
The values generated by the two calls to \code{square} are added by \code{sum-of-squares}, and this result is returned by \code{f}.
Since our focus here is on the environment structures, we will not dwell on how these returned values are passed from call to call;
however, this is also an important aspect of the evaluation process, and we will return to it in detail in \cref{Chapter 5}.



\begin{exercise}
	\label{Exercise 3.9}
	In \cref{Section 1.2.1} we used the substitution model to analyze two procedures for computing factorials, a recursive version
	\begin{scheme}
	  (define (factorial n)
	    (if (= n 1) 1 (* n (factorial (- n 1)))))
	\end{scheme}
	and an iterative version
	\begin{scheme}
	  (define (factorial n) (fact-iter 1 1 n))
	  (define (fact-iter product counter max-count)
	    (if (> counter max-count)
	        product
	        (fact-iter (* counter product)
	                   (+ counter 1)
	                   max-count)))
	\end{scheme}
	Show the environment structures created by evaluating \code{(factorial 6)} using each version of the \code{factorial} procedure.%
	\footnote{
		The environment model will not clarify our claim in \cref{Section 1.2.1} that the interpreter can execute a procedure such as \code{fact-iter} in a constant amount of space using tail recursion.
		We will discuss tail recursion when we deal with the control structure of the interpreter in \cref{Section 5.4}.
	}
\end{exercise}
