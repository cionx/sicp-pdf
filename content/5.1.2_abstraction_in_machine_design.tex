\subsection{Abstraction in Machine Design}
\label{Section 5.1.2}

We will often define a machine to include “primitive” operations that are actually very complex.
For example, in \link{Section 5.4} and \link{Section 5.5} we will treat Scheme’s environment manipulations as primitive.
Such abstraction is valuable because it allows us to ignore the details of parts of a machine so that we can concentrate on other aspects of the design.
The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic.
We can always replace the complex “primitives” by simpler primitive operations.

\begin{figure}[tp]
	\centering
	\includesvg[width=67mm]{fig/chap5/Fig5.5a.svg}
	\caption{
		Data paths and controller for the elaborated \acronym{GCD} machine.
	}
	\label{Figure 5.5}
\end{figure}

Consider the \acronym{GCD} machine.
The machine has an instruction that computes the remainder of the contents of registers \code{a} and \code{b} and assigns the result to register \code{t}.
If we want to construct the \acronym{GCD} machine without using a primitive remainder operation, we must specify how to compute remainders in terms of simpler operations, such as subtraction.
Indeed, we can write a Scheme procedure that finds remainders in this way:
\begin{scheme}
  (define (remainder n d)
    (if (< n d)
        n
        (remainder (- n d) d)))
\end{scheme}
We can thus replace the remainder operation in the \acronym{GCD} machine’s data paths with a subtraction operation and a comparison test.
\link{Figure 5.5} shows the data paths and controller for the elaborated machine.
The instruction
\begin{scheme}
  (assign t (op rem) (reg a) (reg b))
\end{scheme}
in the \acronym{GCD} controller definition is replaced by a sequence of instructions that contains a loop, as shown in \link{Figure 5.6}.



\begin{figure}
	\centering
	\begin{scheme}
	  (controller test-b
	                (test (op =) (reg b) (const 0))
	                (branch (label gcd-done))
	                (assign t (reg a))
	              rem-loop
	                (test (op <) (reg t) (reg b))
	                (branch (label rem-done))
	                (assign t (op -) (reg t) (reg b))
	                (goto (label rem-loop))
	              rem-done
	                (assign a (reg b))
	                (assign b (reg t))
	                (goto (label test-b))
	              gcd-done)
	\end{scheme}
	\caption{
		Controller instruction sequence for the \acronym{GCD} machine in \link{Figure 5.5}.
	}
	\label{Figure 5.6}
\end{figure}



\begin{exercise}
	\label{Exercise 5.3}
	Design a machine to compute square roots using Newton’s method, as described in \link{Section 1.1.7}:
	\begin{scheme}
	  (define (sqrt x)
	    (define (good-enough? guess)
	      (< (abs (- (square guess) x)) 0.001))
	    (define (improve guess)
	      (average guess (/ x guess)))
	    (define (sqrt-iter guess)
	      (if (good-enough? guess)
	          guess
	          (sqrt-iter (improve guess))))
	    (sqrt-iter 1.0))
	\end{scheme}
	Begin by assuming that \code{good-enough?} and \code{improve} operations are available as primitives.
	Then show how to expand these in terms of arithmetic operations.
	Describe each version of the \code{sqrt} machine design by drawing a data-path diagram and writing a controller definition in the register-machine language.
\end{exercise}
