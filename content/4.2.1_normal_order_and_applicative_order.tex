\subsection{Normal Order and Applicative Order}
\label{Section 4.2.1}

In \cref{Section 1.1}, where we began our discussion of models of evaluation, we noted that Scheme is an \newterm{applicative-order} language, namely, that all the arguments to Scheme procedures are evaluated when the procedure is applied.
In contrast, \newterm{normal-order} languages delay evaluation of procedure arguments until the actual argument values are needed.
Delaying evaluation of procedure arguments until the last possible moment (e.g., until they are required by a primitive operation) is called \newterm{lazy evaluation}.%
\footnote{
	The difference between the “lazy” terminology and the “normal-order” terminology is somewhat fuzzy.
	Generally, “lazy” refers to the mechanisms of particular evaluators, while “normal-order” refers to the semantics of languages, independent of any particular evaluation strategy.
	But this is not a hard-and-fast distinction, and the two terminologies are often used interchangeably.
}
Consider the procedure
\begin{scheme}
  (define (try a b) (if (= a 0) 1 b))
\end{scheme}
Evaluating \code{(try 0 (/ 1 0))} generates an error in Scheme.
With lazy evaluation, there would be no error.
Evaluating the expression would return 1, because the argument \code{(/ 1 0)} would never be evaluated.

An example that exploits lazy evaluation is the definition of a procedure \code{unless}
\begin{scheme}
  (define (unless condition usual-value exceptional-value)
    (if condition exceptional-value usual-value))
\end{scheme}
that can be used in expressions such as
\begin{scheme}
  (unless (= b 0)
          (/ a b)
          (begin (display "exception: returning 0") 0))
\end{scheme}
This won’t work in an applicative-order language because both the usual value and the exceptional value will be evaluated before \code{unless} is called (compare \cref{Exercise 1.6}).
An advantage of lazy evaluation is that some procedures, such as \code{unless}, can do useful computation even if evaluation of some of their arguments would produce errors or would not terminate.

If the body of a procedure is entered before an argument has been evaluated we say that the procedure is \newterm{non-strict} in that argument.
If the argument is evaluated before the body of the procedure is entered we say that the procedure is \newterm{strict} in that argument.%
\footnote{
	The “strict” versus “non-strict” terminology means essentially the same thing as “applicative-order” versus “normal-order,” except that it refers to individual procedures and arguments rather than to the language as a whole.
	At a conference on programming languages you might hear someone say, “The normal-order language Hassle has certain strict primitives.
	Other procedures take their arguments by lazy evaluation.”
}
In a purely applicative-order language, all procedures are strict in each argument.
In a purely normal-order language, all compound procedures are non-strict in each argument, and primitive procedures may be either strict or non-strict.
There are also languages (see \cref{Exercise 4.31}) that give programmers detailed control over the strictness of the procedures they define.

A striking example of a procedure that can usefully be made non-strict is \code{cons} (or, in general, almost any constructor for data structures).
One can do useful computation, combining elements to form data structures and operating on the resulting data structures, even if the values of the elements are not known.
It makes perfect sense, for instance, to compute the length of a list without knowing the values of the individual elements in the list.
We will exploit this idea in \cref{Section 4.2.3} to implement the streams of \cref{Chapter 3} as lists formed of non-strict \code{cons} pairs.



\begin{exercise}
	\label{Exercise 4.25}
	Suppose that (in ordinary applicative-order Scheme) we define \code{unless} as shown above and then define \code{factorial} in terms of \code{unless} as
	\begin{scheme}
	  (define (factorial n)
	    (unless (= n 1)
	            (* n (factorial (- n 1)))
	            1))
	\end{scheme}
	What happens if we attempt to evaluate \code{(factorial 5)}?
	Will our definitions work in a normal-order language?
\end{exercise}



\begin{exercise}
	\label{Exercise 4.26}
	Ben Bitdiddle and Alyssa P. Hacker disagree over the importance of lazy evaluation for implementing things such as \code{unless}.
	Ben points out that it’s possible to implement \code{unless} in applicative order as a special form.
	Alyssa counters that, if one did that, \code{unless} would be merely syntax, not a procedure that could be used in conjunction with higher-order procedures.
	Fill in the details on both sides of the argument.
	Show how to implement \code{unless} as a derived expression (like \code{cond} or \code{let}), and give an example of a situation where it might be useful to have \code{unless} available as a procedure, rather than as a special form.
\end{exercise}
