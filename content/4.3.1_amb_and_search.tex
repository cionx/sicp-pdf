\subsection{Amb and Search}
\label{Section 4.3.1}

To extend Scheme to support nondeterminism, we introduce a new special form called \code{amb}.%
\footnote{
	The idea of \code{amb} for nondeterministic programming was first described in 1961 by John McCarthy (see \cref{McCarthy 1963}).
}
The expression
\begin{scheme}
  (amb ⟨~\var{e}\ind{1}~⟩ ⟨~\var{e}\ind{2}~⟩ … ⟨~\var{e}\ind{n}~⟩)
\end{scheme}
returns the value of one of the \( n \) expressions \code{⟨\var{e}\ind{i}⟩} “ambiguously.”
For example, the expression
\begin{scheme}
  (list (amb 1 2 3) (amb 'a 'b))
\end{scheme}
can have six possible values:
\begin{scheme}
  (1 a)   (1 b)   (2 a)   (2 b)   (3 a)   (3 b)
\end{scheme}

\code{amb} with a single choice produces an ordinary (single) value.

\code{amb} with no choices---the expression \code{(amb)}---is an expression with no acceptable values.
Operationally, we can think of \code{(amb)} as an expression that when evaluated causes the computation to “fail”:
The computation aborts and no value is produced.
Using this idea, we can express the requirement that a particular predicate expression \code{p} must be true as follows:
\begin{scheme}
  (define (require p) (if (not p) (amb)))
\end{scheme}

With \code{amb} and \code{require}, we can implement the \code{an-element-of} procedure used above:
\begin{scheme}
  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))
\end{scheme}

\code{an-element-of} fails if the list is empty.
Otherwise it ambiguously returns either the first element of the list or an element chosen from the rest of the list.

We can also express infinite ranges of choices.
The following procedure potentially returns any integer greater than or equal to some given \( n \):
\begin{scheme}
  (define (an-integer-starting-from n)
    (amb n (an-integer-starting-from (+ n 1))))
\end{scheme}

This is like the stream procedure \code{integers-starting-from} described in \cref{Section 3.5.2}, but with an important difference:
The stream procedure returns an object that represents the sequence of all integers beginning with \( n \), whereas the \code{amb} procedure returns a single integer.%
\footnote{
	In actuality, the distinction between nondeterministically returning a single choice and returning all choices depends somewhat on our point of view.
	From the perspective of the code that uses the value, the nondeterministic choice returns a single value.
	From the perspective of the programmer designing the code, the nondeterministic choice potentially returns all possible values, and the computation branches so that each value is investigated separately.
}

Abstractly, we can imagine that evaluating an \code{amb} expression causes time to split into branches, where the computation continues on each branch with one of the possible values of the expression.
We say that \code{amb} represents a \newterm{nondeterministic choice point}.
If we had a machine with a sufficient number of processors that could be dynamically allocated, we could implement the search in a straightforward way.
Execution would proceed as in a sequential machine, until an \code{amb} expression is encountered.
At this point, more processors would be allocated and initialized to continue all of the parallel executions implied by the choice.
Each processor would proceed sequentially as if it were the only choice, until it either terminates by encountering a failure, or it further subdivides, or it finishes.%
\footnote{
	One might object that this is a hopelessly inefficient mechanism.
	It might require millions of processors to solve some easily stated problem this way, and most of the time most of those processors would be idle.
	This objection should be taken in the context of history.
	Memory used to be considered just such an expensive commodity.
	In 1964 a megabyte of \acronym{RAM} cost about \dollar{400,000}.
	Now every personal computer has many megabytes of \acronym{RAM}, and most of the time most of that \acronym{RAM} is unused.
	It is hard to underestimate the cost of mass-produced electronics.
}

On the other hand, if we have a machine that can execute only one process (or a few concurrent processes), we must consider the alternatives sequentially.
One could imagine modifying an evaluator to pick at random a branch to follow whenever it encounters a choice point.
Random choice, however, can easily lead to failing values.
We might try running the evaluator over and over, making random choices and hoping to find a non-failing value, but it is better to \newterm{systematically search} all possible execution paths.
The \code{amb} evaluator that we will develop and work with in this section implements a systematic search as follows:
When the evaluator encounters an application of \code{amb}, it initially selects the first alternative.
This selection may itself lead to a further choice.
The evaluator will always initially choose the first alternative at each choice point.
If a choice results in a failure, then the evaluator automagically%
\footnote{
	Automagically:
	“Automatically, but in a way which, for some reason (typically because it is too complicated, or too ugly, or perhaps even too trivial), the speaker doesn’t feel like explaining.”
	(\cref{Steele et al. 1983}, \cref{Raymond 1993})\label{Footnote 4.47}
}

\newterm{backtracks} to the most recent choice point and tries the next alternative.
If it runs out of alternatives at any choice point, the evaluator will back up to the previous choice point and resume from there.
This process leads to a search strategy known as \newterm{depth-first search} or \newterm{chronological backtracking}.%
\footnote{
	The integration of automatic search strategies into programming languages has had a long and checkered history.
	The first suggestions that nondeterministic algorithms might be elegantly encoded in a programming language with search and automatic backtracking came from Robert \cref{Floyd (1967)}.
	Carl \cref{Hewitt (1969)} invented a programming language called Planner that explicitly supported automatic chronological backtracking, providing for a built-in depth-first search strategy.
	\cref{Sussman et al.
	(1971)} implemented a subset of this language, called MicroPlanner, which was used to support work in problem solving and robot planning.
	Similar ideas, arising from logic and theorem proving, led to the genesis in Edinburgh and Marseille of the elegant language Prolog (which we will discuss in \cref{Section 4.4}).
	After sufficient frustration with automatic search, \cref{McDermott and Sussman (1972)} developed a language called Conniver, which included mechanisms for placing the search strategy under programmer control.
	This proved unwieldy, however, and \cref{Sussman and Stallman 1975} found a more tractable approach while investigating methods of symbolic analysis for electrical circuits.
	They developed a non-chronological backtracking scheme that was based on tracing out the logical dependencies connecting facts, a technique that has come to be known as \newterm{dependency-directed backtracking}.
	Although their method was complex, it produced reasonably efficient programs because it did little redundant search.
	\cref{Doyle (1979)} and \cref{McAllester (1978; 1980)} generalized and clarified the methods of Stallman and Sussman, developing a new paradigm for formulating search that is now called \newterm{truth maintenance}.
	Modern problem-solving systems all use some form of truth-maintenance system as a substrate.
	See \cref{Forbus and deKleer 1993} for a discussion of elegant ways to build truth-maintenance systems and applications using truth maintenance.
	\cref{Zabih et al. 1987} describes a nondeterministic extension to Scheme that is based on \code{amb};
	it is similar to the interpreter described in this section, but more sophisticated, because it uses dependency-directed backtracking rather than chronological backtracking.
	\cref{Winston 1992} gives an introduction to both kinds of backtracking.
}



\subsubsection*{Driver loop}

The driver loop for the \code{amb} evaluator has some unusual properties.
It reads an expression and prints the value of the first non-failing execution, as in the \code{prime-sum-pair} example shown above.
If we want to see the value of the next successful execution, we can ask the interpreter to backtrack and attempt to generate a second non-failing execution.
This is signaled by typing the symbol \code{try-again}.
If any expression except \code{try-again} is given, the interpreter will start a new problem, discarding the unexplored alternatives in the previous problem.
Here is a sample interaction:
\begin{scheme}
  ~\outprint{;;; Amb-Eval input:}~
  (prime-sum-pair '(1 3 5 8) '(20 35 110))
  ~\outprint{;;; Starting a new problem}~
  ~\outprint{;;; Amb-Eval value:}~
  ~\outprint{(3 20)}~

  ~\outprint{;;; Amb-Eval input:}~
  try-again
  ~\outprint{;;; Amb-Eval value:}~
  ~\outprint{(3 110)}~

  ~\outprint{;;; Amb-Eval input:}~
  try-again
  ~\outprint{;;; Amb-Eval value:}~
  ~\outprint{(8 35)}~

  ~\outprint{;;; Amb-Eval input:}~
  try-again
  ~\outprint{;;; There are no more values of}~
  ~\outprint{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}~

  ~\outprint{;;; Amb-Eval input:}~
  (prime-sum-pair '(19 27 30) '(11 36 58))
  ~\outprint{;;; Starting a new problem}~
  ~\outprint{;;; Amb-Eval value:}~
  ~\outprint{(30 11)}~
\end{scheme}



\begin{exercise}
	\label{Exercise 4.35}
	Write a procedure \code{an-integer-between} that returns an integer between two given bounds.
	This can be used to implement a procedure that finds Pythagorean triples, i.e., triples of integers \( (i, j, k) \) between the given bounds such that \( i ≤ j \) and \( i^2 + j^2 = k^2 \), as follows:
	\begin{scheme}
	  (define (a-pythagorean-triple-between low high)
	    (let ((i (an-integer-between low high)))
	      (let ((j (an-integer-between i high)))
	        (let ((k (an-integer-between j high)))
	          (require (= (+ (* i i) (* j j)) (* k k)))
	          (list i j k)))))
	\end{scheme}
\end{exercise}



\begin{exercise}
	\label{Exercise 4.36}
	\cref{Exercise 3.69} discussed how to generate the stream of \emph{all} Pythagorean triples, with no upper bound on the size of the integers to be searched.
	Explain why simply replacing \code{an-integer-between} by \code{an-integer-starting-from} in the procedure in \cref{Exercise 4.35} is not an adequate way to generate arbitrary Pythagorean triples.
	Write a procedure that actually will accomplish this.
	(That is, write a procedure for which repeatedly typing \code{try-again} would in principle eventually generate all Pythagorean triples.)
\end{exercise}



\begin{exercise}
	\label{Exercise 4.37}
	Ben Bitdiddle claims that the following method for generating Pythagorean triples is more efficient than the one in \cref{Exercise 4.35}.
	Is he correct?
	(Hint:
	Consider the number of possibilities that must be explored.)
	\begin{scheme}
	  (define (a-pythagorean-triple-between low high)
	    (let ((i (an-integer-between low high))
	          (hsq (* high high)))
	      (let ((j (an-integer-between i high)))
	        (let ((ksq (+ (* i i) (* j j))))
	          (require (>= hsq ksq))
	          (let ((k (sqrt ksq)))
	            (require (integer? k))
	            (list i j k))))))
	\end{scheme}
\end{exercise}
